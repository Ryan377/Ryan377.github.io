

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="To hate, to love, to think, to feel, to see; all this is nothing but to perceive.">
  <meta name="author" content="chenrui">
  <meta name="keywords" content="">
  
  <title>算法题汇总 - My Blog</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":"TGxc9YICCvt0nq9LsWQVqXIR-gzGzoHsz","app_key":"g61pWrmFa2w876qITKSoChaX","server_url":"https://tgxc9yic.lc-cn-n1-shared.com"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>My Blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/spiderman.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="算法题汇总">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-10-17 22:18" pubdate>
        2021年10月17日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      9.4k 字
    </span>
  

  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      149
       分钟
    </span>
  

  
  
    
      <!-- LeanCloud 统计文章PV -->
      <span id="leancloud-page-views-container" class="post-meta" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="leancloud-page-views"></span> 次
      </span>
    
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">算法题汇总</h1>
            
            <div class="markdown-body">
              <h2 id="一、数据结构"><a href="#一、数据结构" class="headerlink" title="一、数据结构"></a>一、数据结构</h2><h3 id="1-链表"><a href="#1-链表" class="headerlink" title="1. 链表"></a>1. 链表</h3><h4 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>), p = dummy;<br>    ListNode p1 = l1, p2 = l2;<br>    <br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-keyword">null</span> &amp;&amp; p2 != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 比较 p1 和 p2 两个指针</span><br>        <span class="hljs-comment">// 将值较小的的节点接到 p 指针</span><br>        <span class="hljs-keyword">if</span> (p1.val &gt; p2.val) &#123;<br>            p.next = p2;<br>            p2 = p2.next;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            p.next = p1;<br>            p1 = p1.next;<br>        &#125;<br>        <span class="hljs-comment">// p 指针不断前进</span><br>        p = p.next;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (p1 != <span class="hljs-keyword">null</span>) &#123;<br>        p.next = p1;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (p2 != <span class="hljs-keyword">null</span>) &#123;<br>        p.next = p2;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="合并-k-个有序链表"><a href="#合并-k-个有序链表" class="headerlink" title="合并 k 个有序链表"></a>合并 k 个有序链表</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">istNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lists.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 虚拟头结点</span><br>    ListNode dummy = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode p = dummy;<br>    <span class="hljs-comment">// 优先级队列，最小堆</span><br>    PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<br>        lists.length, (a, b)-&gt;(a.val - b.val));<br>    <span class="hljs-comment">// 将 k 个链表的头结点加入最小堆</span><br>    <span class="hljs-keyword">for</span> (ListNode head : lists) &#123;<br>        <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span>)<br>            pq.add(head);<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (!pq.isEmpty()) &#123;<br>        <span class="hljs-comment">// 获取最小节点，接到结果链表中</span><br>        ListNode node = pq.poll();<br>        p.next = node;<br>        <span class="hljs-keyword">if</span> (node.next != <span class="hljs-keyword">null</span>) &#123;<br>            pq.add(node.next);<br>        &#125;<br>        <span class="hljs-comment">// p 指针不断前进</span><br>        p = p.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummy.next;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="单链表的倒数第-k-个节点"><a href="#单链表的倒数第-k-个节点" class="headerlink" title="单链表的倒数第 k 个节点"></a>单链表的倒数第 k 个节点</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 返回链表的倒数第 k 个节点</span><br><span class="hljs-function">ListNode <span class="hljs-title">findFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    ListNode p1 = head;<br>    <span class="hljs-comment">// p1 先走 k 步</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        p1 = p1.next;<br>    &#125;<br>    ListNode p2 = head;<br>    <span class="hljs-comment">// p1 和 p2 同时走 n - k 步</span><br>    <span class="hljs-keyword">while</span> (p1 != <span class="hljs-keyword">null</span>) &#123;<br>        p2 = p2.next;<br>        p1 = p1.next;<br>    &#125;<br>    <span class="hljs-comment">// p2 现在指向第 n - k 个节点</span><br>    <span class="hljs-keyword">return</span> p2;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="单链表的中点"><a href="#单链表的中点" class="headerlink" title="单链表的中点"></a>单链表的中点</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">middleNode</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    ListNode slow = head, fast = head;<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步</span><br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br>    <span class="hljs-comment">// 慢指针指向中点</span><br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-comment">// 快慢指针初始化指向 head</span><br>    ListNode slow = head, fast = head;<br>    <span class="hljs-comment">// 快指针走到末尾时停止</span><br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 慢指针走一步，快指针走两步</span><br>        slow = slow.next;<br>        fast = fast.next.next;<br>        <span class="hljs-comment">// 快慢指针相遇，说明含有环</span><br>        <span class="hljs-keyword">if</span> (slow == fast) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不包含环</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">// plus 返回起点</span><br><span class="hljs-function">ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode fast, slow;<br>    fast = slow = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span> &amp;&amp; fast.next != <span class="hljs-keyword">null</span>) &#123;<br>        fast = fast.next.next;<br>        slow = slow.next;<br>        <span class="hljs-keyword">if</span> (fast == slow) <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// 上面的代码类似 hasCycle 函数</span><br>    <span class="hljs-keyword">if</span> (fast == <span class="hljs-keyword">null</span> || fast.next == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// fast 遇到空指针说明没有环</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 重新指向头结点</span><br>    slow = head;<br>    <span class="hljs-comment">// 快慢指针同步前进，相交点就是环起点</span><br>    <span class="hljs-keyword">while</span> (slow != fast) &#123;<br>        fast = fast.next;<br>        slow = slow.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">ListNode <span class="hljs-title">getIntersectionNode</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>    <span class="hljs-comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span><br>    ListNode p1 = headA, p2 = headB;<br>    <span class="hljs-keyword">while</span> (p1 != p2) &#123;<br>        <span class="hljs-comment">// p1 走一步，如果走到 A 链表末尾，转到 B 链表</span><br>        <span class="hljs-keyword">if</span> (p1 == <span class="hljs-keyword">null</span>) p1 = headB;<br>        <span class="hljs-keyword">else</span>            p1 = p1.next;<br>        <span class="hljs-comment">// p2 走一步，如果走到 B 链表末尾，转到 A 链表</span><br>        <span class="hljs-keyword">if</span> (p2 == <span class="hljs-keyword">null</span>) p2 = headA;<br>        <span class="hljs-keyword">else</span>            p2 = p2.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> p1;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 反转整个</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head.next == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>    ListNode last = reverse(head.next);<br>    head.next.next = head;<br>    head.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;<br><br><span class="hljs-comment">//反转前N个</span><br>ListNode successor = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// 后驱节点</span><br><br><span class="hljs-comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverseN</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <br>        <span class="hljs-comment">// 记录第 n + 1 个节点</span><br>        successor = head.next;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span><br>    ListNode last = reverseN(head.next, n - <span class="hljs-number">1</span>);<br><br>    head.next.next = head;<br>    <span class="hljs-comment">// 让反转之后的 head 节点和后面的节点连起来</span><br>    head.next = successor;<br>    <span class="hljs-keyword">return</span> last;<br>&#125;  <br><br><span class="hljs-comment">//反转一部分</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverseBetween</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (m == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> reverseN(head, n);<br>    &#125;<br>    <span class="hljs-comment">// 前进到反转的起点触发 base case</span><br>    head.next = reverseBetween(head.next, m - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">//k个一组反转</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 区间 [a, b) 包含 k 个待反转元素</span><br>    ListNode a, b;<br>    a = b = head;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        <span class="hljs-comment">// 不足 k 个，不需要反转，base case</span><br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>        b = b.next;<br>    &#125;<br>    <span class="hljs-comment">// 反转前 k 个元素</span><br>    ListNode newHead = reverse(a, b);<br>    <span class="hljs-comment">// 递归反转后续链表并连接起来</span><br>    a.next = reverseKGroup(b, k);<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br><br><span class="hljs-comment">/** 反转区间 [a, b) 的元素，注意是左闭右开 */</span><br><span class="hljs-function">ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode a, ListNode b)</span> </span>&#123;<br>    ListNode pre, cur, nxt;<br>    pre = <span class="hljs-keyword">null</span>; cur = a; nxt = a;<br>    <span class="hljs-comment">// while 终止的条件改一下就行了</span><br>    <span class="hljs-keyword">while</span> (cur != b) &#123;<br>        nxt = cur.next;<br>        cur.next = pre;<br>        pre = cur;<br>        cur = nxt;<br>    &#125;<br>    <span class="hljs-comment">// 返回反转后的头结点</span><br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="回文链表"><a href="#回文链表" class="headerlink" title="回文链表"></a>回文链表</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 回文单链表</span><br><span class="hljs-comment">// 左侧指针</span><br>ListNode left;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    left = head;<br>    <span class="hljs-keyword">return</span> traverse(head);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">traverse</span><span class="hljs-params">(ListNode right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">boolean</span> res = traverse(right.next);<br>    <span class="hljs-comment">// 后序遍历代码</span><br>    res = res &amp;&amp; (right.val == left.val);<br>    left = left.next;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2. 二叉树"></a>2. 二叉树</h3><h4 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 将整棵树的节点翻转</span><br><span class="hljs-function">TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**** 前序遍历位置 ****/</span><br>    <span class="hljs-comment">// root 节点需要交换它的左右子节点</span><br>    TreeNode tmp = root.left;<br>    root.left = root.right;<br>    root.right = tmp;<br><br>    <span class="hljs-comment">// 让左右子节点继续翻转它们的子节点</span><br>    invertTree(root.left);<br>    invertTree(root.right);<br>    <br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="填充二叉树节点的右侧指针"><a href="#填充二叉树节点的右侧指针" class="headerlink" title="填充二叉树节点的右侧指针"></a>填充二叉树节点的右侧指针</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 主函数</span><br><span class="hljs-function">Node <span class="hljs-title">connect</span><span class="hljs-params">(Node root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    connectTwoNode(root.left, root.right);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 辅助函数</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">connectTwoNode</span><span class="hljs-params">(Node node1, Node node2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (node1 == <span class="hljs-keyword">null</span> || node2 == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/**** 前序遍历位置 ****/</span><br>    <span class="hljs-comment">// 将传入的两个节点连接</span><br>    node1.next = node2;<br>    <br>    <span class="hljs-comment">// 连接相同父节点的两个子节点</span><br>    connectTwoNode(node1.left, node1.right);<br>    connectTwoNode(node2.left, node2.right);<br>    <span class="hljs-comment">// 连接跨越父节点的两个子节点</span><br>    connectTwoNode(node1.right, node2.left);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="将二叉树展开为链表"><a href="#将二叉树展开为链表" class="headerlink" title="将二叉树展开为链表"></a><strong>将二叉树展开为链表</strong></h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 定义：将以 root 为根的树拉平为链表</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span>;<br>    <br>    flatten(root.left);<br>    flatten(root.right);<br><br>    <span class="hljs-comment">/**** 后序遍历位置 ****/</span><br>    <span class="hljs-comment">// 1、左右子树已经被拉平成一条链表</span><br>    TreeNode left = root.left;<br>    TreeNode right = root.right;<br>    <br>    <span class="hljs-comment">// 2、将左子树作为右子树</span><br>    root.left = <span class="hljs-keyword">null</span>;<br>    root.right = left;<br><br>    <span class="hljs-comment">// 3、将原先的右子树接到当前右子树的末端</span><br>    TreeNode p = root;<br>    <span class="hljs-keyword">while</span> (p.right != <span class="hljs-keyword">null</span>) &#123;<br>        p = p.right;<br>    &#125;<br>    p.right = right;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function">TreeNode <span class="hljs-title">constructMaximumBinaryTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> build(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">/* 将 nums[lo..hi] 构造成符合条件的树，返回根节点 */</span><br><span class="hljs-function">TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (lo &gt; hi) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 找到数组中的最大值和对应的索引</span><br>    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>, maxVal = Integer.MIN_VALUE;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = lo; i &lt;= hi; i++) &#123;<br>        <span class="hljs-keyword">if</span> (maxVal &lt; nums[i]) &#123;<br>            index = i;<br>            maxVal = nums[i];<br>        &#125;<br>    &#125;<br><br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(maxVal);<br>    <span class="hljs-comment">// 递归调用构造左右子树</span><br>    root.left = build(nums, lo, index - <span class="hljs-number">1</span>);<br>    root.right = build(nums, index + <span class="hljs-number">1</span>, hi);<br>    <br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="通过前序和中序结果构造二叉树"><a href="#通过前序和中序结果构造二叉树" class="headerlink" title="通过前序和中序结果构造二叉树"></a>通过前序和中序结果构造二叉树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span> preStart, <span class="hljs-keyword">int</span> preEnd, </span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (preStart &gt; preEnd) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// root 节点对应的值就是前序遍历数组的第一个元素</span><br>    <span class="hljs-keyword">int</span> rootVal = preorder[preStart];<br>    <span class="hljs-comment">// rootVal 在中序遍历数组中的索引</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[i] == rootVal) &#123;<br>            index = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> leftSize = index - inStart;<br><br>    <span class="hljs-comment">// 先构造出当前根节点</span><br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(rootVal);<br>    <span class="hljs-comment">// 递归构造左右子树</span><br>    root.left = build(preorder, preStart + <span class="hljs-number">1</span>, preStart + leftSize,<br>                      inorder, inStart, index - <span class="hljs-number">1</span>);<br><br>    root.right = build(preorder, preStart + leftSize + <span class="hljs-number">1</span>, preEnd,<br>                       inorder, index + <span class="hljs-number">1</span>, inEnd);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="通过后序和中序遍历结果构造二叉树"><a href="#通过后序和中序遍历结果构造二叉树" class="headerlink" title="通过后序和中序遍历结果构造二叉树"></a>通过后序和中序遍历结果构造二叉树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] inorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd,</span></span><br><span class="hljs-function"><span class="hljs-params">               <span class="hljs-keyword">int</span>[] postorder, <span class="hljs-keyword">int</span> postStart, <span class="hljs-keyword">int</span> postEnd)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (inStart &gt; inEnd) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// root 节点对应的值就是后序遍历数组的最后一个元素</span><br>    <span class="hljs-keyword">int</span> rootVal = postorder[postEnd];<br>    <span class="hljs-comment">// rootVal 在中序遍历数组中的索引</span><br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = inStart; i &lt;= inEnd; i++) &#123;<br>        <span class="hljs-keyword">if</span> (inorder[i] == rootVal) &#123;<br>            index = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 左子树的节点个数</span><br>    <span class="hljs-keyword">int</span> leftSize = index - inStart;<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(rootVal);<br>    <span class="hljs-comment">// 递归构造左右子树</span><br>    root.left = build(inorder, inStart, index - <span class="hljs-number">1</span>,<br>                        postorder, postStart, postStart + leftSize - <span class="hljs-number">1</span>);<br><br>    root.right = build(inorder, index + <span class="hljs-number">1</span>, inEnd,<br>                        postorder, postStart + leftSize, postEnd - <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="寻找重复子树"><a href="#寻找重复子树" class="headerlink" title="寻找重复子树"></a>寻找重复子树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录所有子树以及出现的次数</span><br>HashMap&lt;String, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-comment">// 记录重复的子树根节点</span><br>LinkedList&lt;TreeNode&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function">List&lt;TreeNode&gt; <span class="hljs-title">findDuplicateSubtrees</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    traverse(root);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/* 辅助函数 */</span><br><span class="hljs-function">String <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;#&quot;</span>;<br>    &#125;<br><br>    String left = traverse(root.left);<br>    String right = traverse(root.right);<br><br>    String subTree = left + <span class="hljs-string">&quot;,&quot;</span> + right+ <span class="hljs-string">&quot;,&quot;</span> + root.val;<br><br>    <span class="hljs-keyword">int</span> freq = memo.getOrDefault(subTree, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 多次重复也只会被加入结果集一次</span><br>    <span class="hljs-keyword">if</span> (freq == <span class="hljs-number">1</span>) &#123;<br>        res.add(root);<br>    &#125;<br>    <span class="hljs-comment">// 给子树对应的出现次数加一</span><br>    memo.put(subTree, freq + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">return</span> subTree;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="寻找第-K-小的元素"><a href="#寻找第-K-小的元素" class="headerlink" title="寻找第 K 小的元素"></a>寻找第 K 小的元素</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-comment">// 利用 BST 的中序遍历特性</span><br>    traverse(root, k);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 记录结果</span><br><span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 记录当前元素的排名</span><br><span class="hljs-keyword">int</span> rank = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    traverse(root.left, k);<br>    <span class="hljs-comment">/* 中序遍历代码位置 */</span><br>    rank++;<br>    <span class="hljs-keyword">if</span> (k == rank) &#123;<br>        <span class="hljs-comment">// 找到第 k 小的元素</span><br>        res = root.val;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/*****************/</span><br>    traverse(root.right, k);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="BST-转化累加树"><a href="#BST-转化累加树" class="headerlink" title="BST 转化累加树"></a>BST 转化累加树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">convertBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    traverse(root);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-comment">// 记录累加和</span><br><span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    traverse(root.right);<br>    <span class="hljs-comment">// 维护累加和</span><br>    sum += root.val;<br>    <span class="hljs-comment">// 将 BST 转化成累加树</span><br>    root.val = sum;<br>    traverse(root.left);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="判断-BST-的合法性"><a href="#判断-BST-的合法性" class="headerlink" title="判断 BST 的合法性"></a>判断 BST 的合法性</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> isValidBST(root, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">null</span>);<br>&#125;<br><br><span class="hljs-comment">/* 限定以 root 为根的子树节点必须满足 max.val &gt; root.val &gt; min.val */</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root, TreeNode min, TreeNode max)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-comment">// 若 root.val 不符合 max 和 min 的限制，说明不是合法 BST</span><br>    <span class="hljs-keyword">if</span> (min != <span class="hljs-keyword">null</span> &amp;&amp; root.val &lt;= min.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (max != <span class="hljs-keyword">null</span> &amp;&amp; root.val &gt;= max.val) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-comment">// 限定左子树的最大值是 root.val，右子树的最小值是 root.val</span><br>    <span class="hljs-keyword">return</span> isValidBST(root.left, min, root) <br>        &amp;&amp; isValidBST(root.right, root, max);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="在-BST-中搜索一个数"><a href="#在-BST-中搜索一个数" class="headerlink" title="在 BST 中搜索一个数"></a>在 BST 中搜索一个数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isInBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    <span class="hljs-keyword">if</span> (root.val == target)<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">if</span> (root.val &lt; target) <br>        <span class="hljs-keyword">return</span> isInBST(root.right, target);<br>    <span class="hljs-keyword">if</span> (root.val &gt; target)<br>        <span class="hljs-keyword">return</span> isInBST(root.left, target);<br>    <span class="hljs-comment">// root 该做的事做完了，顺带把框架也完成了，妙</span><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="在-BST-中插入一个数"><a href="#在-BST-中插入一个数" class="headerlink" title="在 BST 中插入一个数"></a>在 BST 中插入一个数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">insertIntoBST</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-comment">// 找到空位置插入新节点</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TreeNode(val);<br>    <span class="hljs-comment">// if (root.val == val)</span><br>    <span class="hljs-comment">//     BST 中一般不会插入已存在元素</span><br>    <span class="hljs-keyword">if</span> (root.val &lt; val) <br>        root.right = insertIntoBST(root.right, val);<br>    <span class="hljs-keyword">if</span> (root.val &gt; val) <br>        root.left = insertIntoBST(root.left, val);<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="在-BST-中删除一个数"><a href="#在-BST-中删除一个数" class="headerlink" title="在 BST 中删除一个数"></a>在 BST 中删除一个数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">deleteNode</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (root.val == key) &#123;<br>        <span class="hljs-comment">// 这两个 if 把情况 1 和 2 都正确处理了</span><br>        <span class="hljs-keyword">if</span> (root.left == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.right;<br>        <span class="hljs-keyword">if</span> (root.right == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> root.left;<br>        <span class="hljs-comment">// 处理情况 3</span><br>        TreeNode minNode = getMin(root.right);<br>        root.val = minNode.val;<br>        root.right = deleteNode(root.right, minNode.val);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &gt; key) &#123;<br>        root.left = deleteNode(root.left, key);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (root.val &lt; key) &#123;<br>        root.right = deleteNode(root.right, key);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><br><span class="hljs-function">TreeNode <span class="hljs-title">getMin</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>    <span class="hljs-comment">// BST 最左边的就是最小的</span><br>    <span class="hljs-keyword">while</span> (node.left != <span class="hljs-keyword">null</span>) node = node.left;<br>    <span class="hljs-keyword">return</span> node;<br>&#125; <br></code></pre></div></td></tr></table></figure>
<h4 id="不同的二叉搜索树"><a href="#不同的二叉搜索树" class="headerlink" title="不同的二叉搜索树"></a>不同的二叉搜索树</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 备忘录</span><br><span class="hljs-keyword">int</span>[][] memo;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">numTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 备忘录的值初始化为 0</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">return</span> count(<span class="hljs-number">1</span>, n);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (lo &gt; hi) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 查备忘录</span><br>    <span class="hljs-keyword">if</span> (memo[lo][hi] != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> memo[lo][hi];<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> mid = lo; mid &lt;= hi; mid++) &#123;<br>        <span class="hljs-keyword">int</span> left = count(lo, mid - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span> right = count(mid + <span class="hljs-number">1</span>, hi);<br>        res += left * right;<br>    &#125;<br>    <span class="hljs-comment">// 将结果存入备忘录</span><br>    memo[lo][hi] = res;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// plus 构造出所有的二叉搜索树</span><br><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TreeNode&gt; <span class="hljs-title">generateTrees</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// 构造闭区间 [1, n] 组成的 BST </span><br>    <span class="hljs-keyword">return</span> build(<span class="hljs-number">1</span>, n);<br>&#125;<br><br><span class="hljs-comment">/* 构造闭区间 [lo, hi] 组成的 BST */</span><br><span class="hljs-function">List&lt;TreeNode&gt; <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span> </span>&#123;<br>    List&lt;TreeNode&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (lo &gt; hi) &#123;<br>        res.add(<span class="hljs-keyword">null</span>);<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-comment">// 1、穷举 root 节点的所有可能。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = lo; i &lt;= hi; i++) &#123;<br>        <span class="hljs-comment">// 2、递归构造出左右子树的所有合法 BST。</span><br>        List&lt;TreeNode&gt; leftTree = build(lo, i - <span class="hljs-number">1</span>);<br>        List&lt;TreeNode&gt; rightTree = build(i + <span class="hljs-number">1</span>, hi);<br>        <span class="hljs-comment">// 3、给 root 节点穷举所有左右子树的组合。</span><br>        <span class="hljs-keyword">for</span> (TreeNode left : leftTree) &#123;<br>            <span class="hljs-keyword">for</span> (TreeNode right : rightTree) &#123;<br>                <span class="hljs-comment">// i 作为根节点 root 的值</span><br>                TreeNode root = <span class="hljs-keyword">new</span> TreeNode(i);<br>                root.left = left;<br>                root.right = right;<br>                res.add(root);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="二叉搜索子树的最大键值和"><a href="#二叉搜索子树的最大键值和" class="headerlink" title="二叉搜索子树的最大键值和"></a>二叉搜索子树的最大键值和</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 全局变量，记录 BST 最大节点之和</span><br><span class="hljs-keyword">int</span> maxSum = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSumBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    traverse(root);<br>    <span class="hljs-keyword">return</span> maxSum;<br>&#125;<br><br><span class="hljs-keyword">int</span>[] traverse(TreeNode root) &#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<br>            <span class="hljs-number">1</span>, Integer.MAX_VALUE, Integer.MIN_VALUE, <span class="hljs-number">0</span><br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归计算左右子树</span><br>    <span class="hljs-keyword">int</span>[] left = traverse(root.left);<br>    <span class="hljs-keyword">int</span>[] right = traverse(root.right);<br><br>    <span class="hljs-comment">/******* 后序遍历位置 *******/</span><br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">4</span>];<br>    <span class="hljs-comment">// 这个 if 在判断以 root 为根的二叉树是不是 BST</span><br>    <span class="hljs-keyword">if</span> (left[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp; right[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span> &amp;&amp;<br>        root.val &gt; left[<span class="hljs-number">2</span>] &amp;&amp; root.val &lt; right[<span class="hljs-number">1</span>]) &#123;<br>        <span class="hljs-comment">// 以 root 为根的二叉树是 BST</span><br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">// 计算以 root 为根的这棵 BST 的最小值</span><br>        res[<span class="hljs-number">1</span>] = Math.min(left[<span class="hljs-number">1</span>], root.val);<br>        <span class="hljs-comment">// 计算以 root 为根的这棵 BST 的最大值</span><br>        res[<span class="hljs-number">2</span>] = Math.max(right[<span class="hljs-number">2</span>], root.val);<br>        <span class="hljs-comment">// 计算以 root 为根的这棵 BST 所有节点之和</span><br>        res[<span class="hljs-number">3</span>] = left[<span class="hljs-number">3</span>] + right[<span class="hljs-number">3</span>] + root.val;<br>        <span class="hljs-comment">// 更新全局变量</span><br>        maxSum = Math.max(maxSum, res[<span class="hljs-number">3</span>]);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 以 root 为根的二叉树不是 BST</span><br>        res[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">// 其他的值都没必要计算了，因为用不到</span><br>    &#125;<br>    <span class="hljs-comment">/**************************/</span><br><br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="二叉树的序列化与反序列化"><a href="#二叉树的序列化与反序列化" class="headerlink" title="二叉树的序列化与反序列化"></a>二叉树的序列化与反序列化</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String SEP = <span class="hljs-string">&quot;,&quot;</span>;<br>String NULL = <span class="hljs-string">&quot;#&quot;</span>;<br><br><span class="hljs-comment">/* 主函数，将二叉树序列化为字符串 */</span><br><span class="hljs-function">String <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    serialize(root, sb);<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br><br><span class="hljs-comment">/* 辅助函数，将二叉树存入 StringBuilder */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(TreeNode root, StringBuilder sb)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) &#123;<br>        sb.append(NULL).append(SEP);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/****** 前序遍历位置 ******/</span><br>    sb.append(root.val).append(SEP);<br>    <span class="hljs-comment">/***********************/</span><br><br>    serialize(root.left, sb);<br>    serialize(root.right, sb);<br>&#125;<br><br><span class="hljs-comment">/* 主函数，将字符串反序列化为二叉树结构 */</span><br><span class="hljs-function">TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(String data)</span> </span>&#123;<br>    <span class="hljs-comment">// 将字符串转化成列表</span><br>    LinkedList&lt;String&gt; nodes = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (String s : data.split(SEP)) &#123;<br>        nodes.addLast(s);<br>    &#125;<br>    <span class="hljs-keyword">return</span> deserialize(nodes);<br>&#125;<br><br><span class="hljs-comment">/* 辅助函数，通过 nodes 列表构造二叉树 */</span><br><span class="hljs-function">TreeNode <span class="hljs-title">deserialize</span><span class="hljs-params">(LinkedList&lt;String&gt; nodes)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nodes.isEmpty()) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">/****** 前序遍历位置 ******/</span><br>    <span class="hljs-comment">// 列表最左侧就是根节点</span><br>    String first = nodes.removeFirst();<br>    <span class="hljs-keyword">if</span> (first.equals(NULL)) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(Integer.parseInt(first));<br>    <span class="hljs-comment">/***********************/</span><br><br>    root.left = deserialize(nodes);<br>    root.right = deserialize(nodes);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="扁平化嵌套列表迭代器"><a href="#扁平化嵌套列表迭代器" class="headerlink" title="扁平化嵌套列表迭代器*"></a>扁平化嵌套列表迭代器*</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br></code></pre></div></td></tr></table></figure>
<h4 id="二叉树的最近公共祖先"><a href="#二叉树的最近公共祖先" class="headerlink" title="二叉树的最近公共祖先"></a>二叉树的最近公共祖先</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">TreeNode <span class="hljs-title">lowestCommonAncestor</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (root == p || root == q) <span class="hljs-keyword">return</span> root;<br><br>    TreeNode left = lowestCommonAncestor(root.left, p, q);<br>    TreeNode right = lowestCommonAncestor(root.right, p, q);<br>    <span class="hljs-comment">// 情况 1</span><br>    <span class="hljs-keyword">if</span> (left != <span class="hljs-keyword">null</span> &amp;&amp; right != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    <span class="hljs-comment">// 情况 2</span><br>    <span class="hljs-keyword">if</span> (left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">// 情况 3</span><br>    <span class="hljs-keyword">return</span> left == <span class="hljs-keyword">null</span> ? right : left;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="完全二叉树节点数"><a href="#完全二叉树节点数" class="headerlink" title="完全二叉树节点数"></a>完全二叉树节点数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countNodes</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    TreeNode l = root, r = root;<br>    <span class="hljs-comment">// 记录左、右子树的高度</span><br>    <span class="hljs-keyword">int</span> hl = <span class="hljs-number">0</span>, hr = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (l != <span class="hljs-keyword">null</span>) &#123;<br>        l = l.left;<br>        hl++;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (r != <span class="hljs-keyword">null</span>) &#123;<br>        r = r.right;<br>        hr++;<br>    &#125;<br>    <span class="hljs-comment">// 如果左右子树的高度相同，则是一棵满二叉树</span><br>    <span class="hljs-keyword">if</span> (hl == hr) &#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>)Math.pow(<span class="hljs-number">2</span>, hl) - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果左右高度不同，则按照普通二叉树的逻辑计算</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + countNodes(root.left) + countNodes(root.right);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="3-图"><a href="#3-图" class="headerlink" title="3. 图"></a>3. 图</h3><h4 id="所有可能路径"><a href="#所有可能路径" class="headerlink" title="所有可能路径"></a>所有可能路径</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录所有路径</span><br>List&lt;List&lt;Integer&gt;&gt; res = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(<span class="hljs-keyword">int</span>[][] graph) &#123;<br>    LinkedList&lt;Integer&gt; path = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    traverse(graph, <span class="hljs-number">0</span>, path);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">/* 图的遍历框架 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] graph, <span class="hljs-keyword">int</span> s, LinkedList&lt;Integer&gt; path)</span> </span>&#123;<br><br>    <span class="hljs-comment">// 添加节点 s 到路径</span><br>    path.addLast(s);<br><br>    <span class="hljs-keyword">int</span> n = graph.length;<br>    <span class="hljs-keyword">if</span> (s == n - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 到达终点</span><br>        res.add(<span class="hljs-keyword">new</span> LinkedList&lt;&gt;(path));<br>        path.removeLast();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 递归每个相邻节点</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> v : graph[s]) &#123;<br>        traverse(graph, v, path);<br>    &#125;<br><br>    <span class="hljs-comment">// 从路径移出节点 s</span><br>    path.removeLast();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="课程表"><a href="#课程表" class="headerlink" title="课程表"></a>课程表</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 记录一次 traverse 递归经过的节点</span><br><span class="hljs-keyword">boolean</span>[] onPath;<br><span class="hljs-comment">// 记录遍历过的节点，防止走回头路</span><br><span class="hljs-keyword">boolean</span>[] visited;<br><span class="hljs-comment">// 记录图中是否有环</span><br><span class="hljs-keyword">boolean</span> hasCycle = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;<br>    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);<br>    <br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[numCourses];<br>    onPath = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[numCourses];<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        <span class="hljs-comment">// 遍历图中的所有节点</span><br>        traverse(graph, i);<br>    &#125;<br>    <span class="hljs-comment">// 只要没有循环依赖可以完成所有课程</span><br>    <span class="hljs-keyword">return</span> !hasCycle;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(List&lt;Integer&gt;[] graph, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (onPath[s]) &#123;<br>        <span class="hljs-comment">// 出现环</span><br>        hasCycle = <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (visited[s] || hasCycle) &#123;<br>        <span class="hljs-comment">// 如果已经找到了环，也不用再遍历了</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 前序遍历代码位置</span><br>    visited[s] = <span class="hljs-keyword">true</span>;<br>    onPath[s] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t : graph[s]) &#123;<br>        traverse(graph, t);<br>    &#125;<br>    <span class="hljs-comment">// 后序遍历代码位置</span><br>    onPath[s] = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><br>List&lt;Integer&gt;[] buildGraph(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) &#123;<br>    <span class="hljs-comment">// 图中共有 numCourses 个节点</span><br>    List&lt;Integer&gt;[] graph = <span class="hljs-keyword">new</span> LinkedList[numCourses];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        graph[i] = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] edge : prerequisites) &#123;<br>        <span class="hljs-keyword">int</span> from = edge[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> to = edge[<span class="hljs-number">0</span>];<br>        <span class="hljs-comment">// 修完课程 from 才能修课程 to</span><br>        <span class="hljs-comment">// 在图中添加一条从 from 指向 to 的有向边</span><br>        graph[from].add(to);<br>    &#125;<br>    <span class="hljs-keyword">return</span> graph;<br>&#125;<br><br><span class="hljs-comment">// 拓扑排序</span><br><span class="hljs-keyword">boolean</span>[] visited;<br><span class="hljs-comment">// 记录后序遍历结果</span><br>List&lt;Integer&gt; postorder = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-keyword">int</span>[] findOrder(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites) &#123;<br>    <span class="hljs-comment">// 先保证图中无环</span><br>    <span class="hljs-keyword">if</span> (!canFinish(numCourses, prerequisites)) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 建图</span><br>    List&lt;Integer&gt;[] graph = buildGraph(numCourses, prerequisites);<br>    <span class="hljs-comment">// 进行 DFS 遍历</span><br>    visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[numCourses];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        traverse(graph, i);<br>    &#125;<br>    <span class="hljs-comment">// 将后序遍历结果反转，转化成 int[] 类型</span><br>    Collections.reverse(postorder);<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        res[i] = postorder.get(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">traverse</span><span class="hljs-params">(List&lt;Integer&gt;[] graph, <span class="hljs-keyword">int</span> s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (visited[s]) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    visited[s] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> t : graph[s]) &#123;<br>        traverse(graph, t);<br>    &#125;<br>    <span class="hljs-comment">// 后序遍历位置</span><br>    postorder.add(s);<br>&#125;<br><br><span class="hljs-comment">// 参考上一题的解法</span><br><span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span></span>;<br><br><span class="hljs-comment">// 参考前文代码</span><br>List&lt;Integer&gt;[] buildGraph(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites);<br></code></pre></div></td></tr></table></figure>
<h4 id="搜索名人"><a href="#搜索名人" class="headerlink" title="搜索名人"></a>搜索名人</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findCelebrity</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-comment">// 先假设 cand 是名人</span><br>    <span class="hljs-keyword">int</span> cand = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> other = <span class="hljs-number">1</span>; other &lt; n; other++) &#123;<br>        <span class="hljs-keyword">if</span> (!knows(other, cand) || knows(cand, other)) &#123;<br>            <span class="hljs-comment">// cand 不可能是名人，排除</span><br>            <span class="hljs-comment">// 假设 other 是名人</span><br>            cand = other;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// other 不可能是名人，排除</span><br>            <span class="hljs-comment">// 什么都不用做，继续假设 cand 是名人</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 现在的 cand 是排除的最后结果，但不能保证一定是名人</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> other = <span class="hljs-number">0</span>; other &lt; n; other++) &#123;<br>        <span class="hljs-keyword">if</span> (cand == other) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-comment">// 需要保证其他人都认识 cand，且 cand 不认识任何其他人</span><br>        <span class="hljs-keyword">if</span> (!knows(other, cand) || knows(cand, other)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> cand;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="4-设计数据结构"><a href="#4-设计数据结构" class="headerlink" title="4. 设计数据结构"></a>4. 设计数据结构</h3><h4 id="Union-Find-算法"><a href="#Union-Find-算法" class="headerlink" title="Union-Find 算法"></a>Union-Find 算法</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UF</span> </span>&#123;<br>    <span class="hljs-comment">// 连通分量个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-comment">// 存储一棵树</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] parent;<br>    <span class="hljs-comment">// 记录树的“重量”</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UF</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.count = n;<br>        parent = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        size = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            parent[i] = i;<br>            size[i] = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">union</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-keyword">if</span> (rootP == rootQ)<br>            <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">// 小树接到大树下面，较平衡</span><br>        <span class="hljs-keyword">if</span> (size[rootP] &gt; size[rootQ]) &#123;<br>            parent[rootQ] = rootP;<br>            size[rootP] += size[rootQ];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            parent[rootP] = rootQ;<br>            size[rootQ] += size[rootP];<br>        &#125;<br>        count--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">connected</span><span class="hljs-params">(<span class="hljs-keyword">int</span> p, <span class="hljs-keyword">int</span> q)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> rootP = find(p);<br>        <span class="hljs-keyword">int</span> rootQ = find(q);<br>        <span class="hljs-keyword">return</span> rootP == rootQ;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (parent[x] != x) &#123;<br>            <span class="hljs-comment">// 进行路径压缩</span><br>            parent[x] = parent[parent[x]];<br>            x = parent[x];<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="LRU算法实现"><a href="#LRU算法实现" class="headerlink" title="LRU算法实现"></a>LRU算法实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cap;<br>    LinkedHashMap&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123; <br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!cache.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 将 key 变为最近使用</span><br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(key)) &#123;<br>            <span class="hljs-comment">// 修改 key 的值</span><br>            cache.put(key, val);<br>            <span class="hljs-comment">// 将 key 变为最近使用</span><br>            makeRecently(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (cache.size() &gt;= <span class="hljs-keyword">this</span>.cap) &#123;<br>            <span class="hljs-comment">// 链表头部就是最久未使用的 key</span><br>            <span class="hljs-keyword">int</span> oldestKey = cache.keySet().iterator().next();<br>            cache.remove(oldestKey);<br>        &#125;<br>        <span class="hljs-comment">// 将新的 key 添加链表尾部</span><br>        cache.put(key, val);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> val = cache.get(key);<br>        <span class="hljs-comment">// 删除 key，重新插入到队尾</span><br>        cache.remove(key);<br>        cache.put(key, val);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="LFU算法实现"><a href="#LFU算法实现" class="headerlink" title="LFU算法实现"></a>LFU算法实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> </span>&#123;<br>    <span class="hljs-comment">// key 到 val 的映射，我们后文称为 KV 表</span><br>    HashMap&lt;Integer, Integer&gt; keyToVal;<br>    <span class="hljs-comment">// key 到 freq 的映射，我们后文称为 KF 表</span><br>    HashMap&lt;Integer, Integer&gt; keyToFreq;<br>    <span class="hljs-comment">// freq 到 key 列表的映射，我们后文称为 FK 表</span><br>    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;<br>    <span class="hljs-comment">// 记录最小的频次</span><br>    <span class="hljs-keyword">int</span> minFreq;<br>    <span class="hljs-comment">// 记录 LFU 缓存的最大容量</span><br>    <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LFUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        keyToVal = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        keyToFreq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        freqToKeys = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>        <span class="hljs-keyword">this</span>.minFreq = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!keyToVal.containsKey(key)) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">// 增加 key 对应的 freq</span><br>        increaseFreq(key);<br>        <span class="hljs-keyword">return</span> keyToVal.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cap &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br><br>        <span class="hljs-comment">/* 若 key 已存在，修改对应的 val 即可 */</span><br>        <span class="hljs-keyword">if</span> (keyToVal.containsKey(key)) &#123;<br>            keyToVal.put(key, val);<br>            <span class="hljs-comment">// key 对应的 freq 加一</span><br>            increaseFreq(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">/* key 不存在，需要插入 */</span><br>        <span class="hljs-comment">/* 容量已满的话需要淘汰一个 freq 最小的 key */</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.cap &lt;= keyToVal.size()) &#123;<br>            removeMinFreqKey();<br>        &#125;<br><br>        <span class="hljs-comment">/* 插入 key 和 val，对应的 freq 为 1 */</span><br>        <span class="hljs-comment">// 插入 KV 表</span><br>        keyToVal.put(key, val);<br>        <span class="hljs-comment">// 插入 KF 表</span><br>        keyToFreq.put(key, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 插入 FK 表</span><br>        freqToKeys.putIfAbsent(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>        freqToKeys.get(<span class="hljs-number">1</span>).add(key);<br>        <span class="hljs-comment">// 插入新 key 后最小的 freq 肯定是 1</span><br>        <span class="hljs-keyword">this</span>.minFreq = <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMinFreqKey</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// freq 最小的 key 列表</span><br>        LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(<span class="hljs-keyword">this</span>.minFreq);<br>        <span class="hljs-comment">// 其中最先被插入的那个 key 就是该被淘汰的 key</span><br>        <span class="hljs-keyword">int</span> deletedKey = keyList.iterator().next();<br>        <span class="hljs-comment">/* 更新 FK 表 */</span><br>        keyList.remove(deletedKey);<br>        <span class="hljs-keyword">if</span> (keyList.isEmpty()) &#123;<br>            freqToKeys.remove(<span class="hljs-keyword">this</span>.minFreq);<br>            <span class="hljs-comment">// 问：这里需要更新 minFreq 的值吗？</span><br>        &#125;<br>        <span class="hljs-comment">/* 更新 KV 表 */</span><br>        keyToVal.remove(deletedKey);<br>        <span class="hljs-comment">/* 更新 KF 表 */</span><br>        keyToFreq.remove(deletedKey);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseFreq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> freq = keyToFreq.get(key);<br>        <span class="hljs-comment">/* 更新 KF 表 */</span><br>        keyToFreq.put(key, freq + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">/* 更新 FK 表 */</span><br>        <span class="hljs-comment">// 将 key 从 freq 对应的列表中删除</span><br>        freqToKeys.get(freq).remove(key);<br>        <span class="hljs-comment">// 将 key 加入 freq + 1 对应的列表中</span><br>        freqToKeys.putIfAbsent(freq + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>        freqToKeys.get(freq + <span class="hljs-number">1</span>).add(key);<br>        <span class="hljs-comment">// 如果 freq 对应的列表空了，移除这个 freq</span><br>        <span class="hljs-keyword">if</span> (freqToKeys.get(freq).isEmpty()) &#123;<br>            freqToKeys.remove(freq);<br>            <span class="hljs-comment">// 如果这个 freq 恰好是 minFreq，更新 minFreq</span><br>            <span class="hljs-keyword">if</span> (freq == <span class="hljs-keyword">this</span>.minFreq) &#123;<br>                <span class="hljs-keyword">this</span>.minFreq++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="最大频率栈"><a href="#最大频率栈" class="headerlink" title="最大频率栈"></a>最大频率栈</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreqStack</span> </span>&#123;<br>    <span class="hljs-comment">// 记录 FreqStack 中元素的最大频率</span><br>    <span class="hljs-keyword">int</span> maxFreq = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录 FreqStack 中每个 val 对应的出现频率，后文就称为 VF 表</span><br>    HashMap&lt;Integer, Integer&gt; valToFreq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// 记录频率 freq 对应的 val 列表，后文就称为 FV 表</span><br>    HashMap&lt;Integer, Stack&lt;Integer&gt;&gt; freqToVals = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 修改 VF 表：val 对应的 freq 加一</span><br>        <span class="hljs-keyword">int</span> freq = valToFreq.getOrDefault(val, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>        valToFreq.put(val, freq);<br>        <span class="hljs-comment">// 修改 FV 表：在 freq 对应的列表加上 val</span><br>        freqToVals.putIfAbsent(freq, <span class="hljs-keyword">new</span> Stack&lt;&gt;());<br>        freqToVals.get(freq).push(val);<br>        <span class="hljs-comment">// 更新 maxFreq</span><br>        maxFreq = Math.max(maxFreq, freq);<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 修改 FV 表：pop 出一个 maxFreq 对应的元素 v</span><br>        Stack&lt;Integer&gt; vals = freqToVals.get(maxFreq);<br>        <span class="hljs-keyword">int</span> v = vals.pop();<br>        <span class="hljs-comment">// 修改 VF 表：v 对应的 freq 减一</span><br>        <span class="hljs-keyword">int</span> freq = valToFreq.get(v) - <span class="hljs-number">1</span>;<br>        valToFreq.put(v, freq);<br>        <span class="hljs-comment">// 更新 maxFreq</span><br>        <span class="hljs-keyword">if</span> (vals.isEmpty()) &#123;<br>            <span class="hljs-comment">// 如果 maxFreq 对应的元素空了</span><br>            maxFreq--;<br>        &#125;<br>        <span class="hljs-keyword">return</span> v;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="数据流中计算中位数"><a href="#数据流中计算中位数" class="headerlink" title="数据流中计算中位数"></a>数据流中计算中位数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MedianFinder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; large;<br>    <span class="hljs-keyword">private</span> PriorityQueue&lt;Integer&gt; small;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 小顶堆</span><br>        large = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;();<br>        <span class="hljs-comment">// 大顶堆</span><br>        small = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((a, b) -&gt; &#123;<br>            <span class="hljs-keyword">return</span> b - a;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 如果元素不一样多，多的那个堆的堆顶元素就是中位数</span><br>        <span class="hljs-keyword">if</span> (large.size() &lt; small.size()) &#123;<br>            <span class="hljs-keyword">return</span> small.peek();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (large.size() &gt; small.size()) &#123;<br>            <span class="hljs-keyword">return</span> large.peek();<br>        &#125;<br>        <span class="hljs-comment">// 如果元素一样多，两个堆堆顶元素的平均数是中位数</span><br>        <span class="hljs-keyword">return</span> (large.peek() + small.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 正确的代码实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (small.size() &gt;= large.size()) &#123;<br>            small.offer(num);<br>            large.offer(small.poll());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            large.offer(num);<br>            small.offer(large.poll());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="设计朋友圈时间线"><a href="#设计朋友圈时间线" class="headerlink" title="设计朋友圈时间线*"></a>设计朋友圈时间线*</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br></code></pre></div></td></tr></table></figure>
<h4 id="下一个更大元素"><a href="#下一个更大元素" class="headerlink" title="下一个更大元素"></a>下一个更大元素</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElement</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(nums.size()</span>)</span>; <span class="hljs-comment">// 存放答案的数组</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-comment">// 倒着往栈里放</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 判定个子高矮</span><br>        <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i]) &#123;<br>            <span class="hljs-comment">// 矮个起开，反正也被挡着了。。。</span><br>            s.pop();<br>        &#125;<br>        <span class="hljs-comment">// nums[i] 身后的 next great number</span><br>        res[i] = s.empty() ? -<span class="hljs-number">1</span> : s.top();<br>        <span class="hljs-comment">// </span><br>        s.push(nums[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// plus 环形</span><br><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">nextGreaterElements</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.size();<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(n)</span></span>;<br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s;<br>    <span class="hljs-comment">// 假装这个数组长度翻倍了</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// 索引要求模，其他的和模板一样</span><br>        <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; s.top() &lt;= nums[i % n])<br>            s.pop();<br>        res[i % n] = s.empty() ? -<span class="hljs-number">1</span> : s.top();<br>        s.push(nums[i % n]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="一月有多少天"><a href="#一月有多少天" class="headerlink" title="一月有多少天"></a>一月有多少天</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dailyTemperatures</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; T)</span> </span>&#123;<br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">res</span><span class="hljs-params">(T.size()</span>)</span>;<br>    <span class="hljs-comment">// 这里放元素索引，而不是元素</span><br>    stack&lt;<span class="hljs-keyword">int</span>&gt; s; <br>    <span class="hljs-comment">/* 单调栈模板 */</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = T.size() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!s.empty() &amp;&amp; T[s.top()] &lt;= T[i]) &#123;<br>            s.pop();<br>        &#125;<br>        <span class="hljs-comment">// 得到索引间距</span><br>        res[i] = s.empty() ? <span class="hljs-number">0</span> : (s.top() - i); <br>        <span class="hljs-comment">// 将索引入栈，而不是元素</span><br>        s.push(i); <br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="滑动窗口最大值"><a href="#滑动窗口最大值" class="headerlink" title="滑动窗口最大值"></a>滑动窗口最大值</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/* 单调队列的实现 */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MonotonicQueue</span> </span>&#123;<br>    LinkedList&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-comment">// 将小于 n 的元素全部删除</span><br>        <span class="hljs-keyword">while</span> (!q.isEmpty() &amp;&amp; q.getLast() &lt; n) &#123;<br>            q.pollLast();<br>        &#125;<br>        <span class="hljs-comment">// 然后将 n 加入尾部</span><br>        q.addLast(n);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">max</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> q.getFirst();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (n == q.getFirst()) &#123;<br>            q.pollFirst();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/* 解题函数的实现 */</span><br><span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    MonotonicQueue window = <span class="hljs-keyword">new</span> MonotonicQueue();<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &lt; k - <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//先填满窗口的前 k - 1</span><br>            window.push(nums[i]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 窗口向前滑动，加入新数字</span><br>            window.push(nums[i]);<br>            <span class="hljs-comment">// 记录当前窗口的最大值</span><br>            res.add(window.max());<br>            <span class="hljs-comment">// 移出旧数字</span><br>            window.pop(nums[i - k + <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 需要转成 int[] 数组再返回</span><br>    <span class="hljs-keyword">int</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[res.size()];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; res.size(); i++) &#123;<br>        arr[i] = res.get(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="二叉堆实现优先级队列"><a href="#二叉堆实现优先级队列" class="headerlink" title="二叉堆实现优先级队列*"></a>二叉堆实现优先级队列*</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br></code></pre></div></td></tr></table></figure>
<h4 id="队列实现栈和栈实现队列"><a href="#队列实现栈和栈实现队列" class="headerlink" title="队列实现栈和栈实现队列*"></a>队列实现栈和栈实现队列*</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><br></code></pre></div></td></tr></table></figure>
<h3 id="5-数组"><a href="#5-数组" class="headerlink" title="5. 数组"></a>5. 数组</h3><h4 id="优势洗牌"><a href="#优势洗牌" class="headerlink" title="优势洗牌"></a>优势洗牌</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] advantageCount(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2) &#123;<br>    <span class="hljs-keyword">int</span> n = nums1.length;<br>    <span class="hljs-comment">// 给 nums2 降序排序</span><br>    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; maxpq = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;(<br>        (<span class="hljs-keyword">int</span>[] pair1, <span class="hljs-keyword">int</span>[] pair2) -&gt; &#123; <br>            <span class="hljs-keyword">return</span> pair2[<span class="hljs-number">1</span>] - pair1[<span class="hljs-number">1</span>];<br>        &#125;<br>    );<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        maxpq.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i, nums2[i]&#125;);<br>    &#125;<br>    <span class="hljs-comment">// 给 nums1 升序排序</span><br>    Arrays.sort(nums1);<br><br>    <span class="hljs-comment">// nums1[left] 是最小值，nums1[right] 是最大值</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br><br>    <span class="hljs-keyword">while</span> (!maxpq.isEmpty()) &#123;<br>        <span class="hljs-keyword">int</span>[] pair = maxpq.poll();<br>        <span class="hljs-comment">// maxval 是 nums2 中的最大值，i 是对应索引</span><br>        <span class="hljs-keyword">int</span> i = pair[<span class="hljs-number">0</span>], maxval = pair[<span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (maxval &lt; nums1[right]) &#123;<br>            <span class="hljs-comment">// 如果 nums1[right] 能胜过 maxval，那就自己上</span><br>            res[i] = nums1[right];<br>            right--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 否则用最小值混一下，养精蓄锐</span><br>            res[i] = nums1[left];<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="二分搜索"><a href="#二分搜索" class="headerlink" title="二分搜索"></a>二分搜索</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>; <br>    <span class="hljs-keyword">while</span>(left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>; <br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 直接返回</span><br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接返回</span><br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">left_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定左侧边界</span><br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 left 越界的情况</span><br>    <span class="hljs-keyword">if</span> (left &gt;= nums.length || nums[left] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> left;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">right_bound</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-keyword">int</span> mid = left + (right - left) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (nums[mid] &lt; target) &#123;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] &gt; target) &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[mid] == target) &#123;<br>            <span class="hljs-comment">// 别返回，锁定右侧边界</span><br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 最后要检查 right 越界的情况</span><br>    <span class="hljs-keyword">if</span> (right &lt; <span class="hljs-number">0</span> || nums[right] != target)<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> right;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a>分割数组的最大值</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">splitArray</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> m)</span> </span>&#123;<br>    <span class="hljs-comment">// 一般搜索区间是左开右闭的，所以 hi 要额外加一</span><br>    <span class="hljs-keyword">int</span> lo = getMax(nums), hi = getSum(nums) + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;<br>        <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 根据分割子数组的个数收缩搜索区间</span><br>        <span class="hljs-keyword">int</span> n = split(nums, mid);<br>        <span class="hljs-keyword">if</span> (n == m) &#123;<br>            <span class="hljs-comment">// 收缩右边界，达到搜索左边界的目的</span><br>            hi = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &lt; m) &#123;<br>            <span class="hljs-comment">// 最大子数组和上限高了，减小一些</span><br>            hi = mid;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (n &gt; m) &#123;<br>            <span class="hljs-comment">// 最大子数组和上限低了，增加一些</span><br>            lo = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> lo;<br>&#125;<br><br><span class="hljs-comment">/* 辅助函数，若限制最大子数组和为 max，</span><br><span class="hljs-comment">计算 nums 至少可以被分割成几个子数组 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">split</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> max)</span> </span>&#123;<br>    <span class="hljs-comment">// 至少可以分割的子数组数量</span><br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 记录每个子数组的元素和</span><br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (sum + nums[i] &gt; max) &#123;<br>            <span class="hljs-comment">// 如果当前子数组和大于 max 限制</span><br>            <span class="hljs-comment">// 则这个子数组不能再添加元素了</span><br>            count++;<br>            sum = nums[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前子数组和还没达到 max 限制</span><br>            <span class="hljs-comment">// 还可以添加元素</span><br>            sum += nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><br><span class="hljs-comment">// 计算数组中的最大值</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getMax</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums)<br>        res = Math.max(n, res);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 计算数组元素和</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> n : nums)<br>        res += n;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="最小覆盖字串"><a href="#最小覆盖字串" class="headerlink" title="最小覆盖字串"></a>最小覆盖字串</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; need, window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) need[c]++;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 记录最小覆盖子串的起始索引及长度</span><br>    <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, len = INT_MAX;<br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-comment">// c 是将移入窗口的字符</span><br>        <span class="hljs-keyword">char</span> c = s[right];<br>        <span class="hljs-comment">// 右移窗口</span><br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        <span class="hljs-keyword">if</span> (need.count(c)) &#123;<br>            window[c]++;<br>            <span class="hljs-keyword">if</span> (window[c] == need[c])<br>                valid++;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (valid == need.size()) &#123;<br>            <span class="hljs-comment">// 在这里更新最小覆盖子串</span><br>            <span class="hljs-keyword">if</span> (right - left &lt; len) &#123;<br>                start = left;<br>                len = right - left;<br>            &#125;<br>            <span class="hljs-comment">// d 是将移出窗口的字符</span><br>            <span class="hljs-keyword">char</span> d = s[left];<br>            <span class="hljs-comment">// 左移窗口</span><br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.count(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window[d] == need[d])<br>                    valid--;<br>                window[d]--;<br>            &#125;                    <br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 返回最小覆盖子串</span><br>    <span class="hljs-keyword">return</span> len == INT_MAX ?<br>        <span class="hljs-string">&quot;&quot;</span> : s.substr(start, len);<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="字符串排列"><a href="#字符串排列" class="headerlink" title="字符串排列"></a>字符串排列</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 判断 s 中是否存在 t 的排列</span><br><span class="hljs-function">bool <span class="hljs-title">checkInclusion</span><span class="hljs-params">(string t, string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; need, window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) need[c]++;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        <span class="hljs-keyword">if</span> (need.count(c)) &#123;<br>            window[c]++;<br>            <span class="hljs-keyword">if</span> (window[c] == need[c])<br>                valid++;<br>        &#125;<br><br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (right - left &gt;= t.size()) &#123;<br>            <span class="hljs-comment">// 在这里判断是否找到了合法的子串</span><br>            <span class="hljs-keyword">if</span> (valid == need.size())<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.count(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window[d] == need[d])<br>                    valid--;<br>                window[d]--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 未找到符合条件的子串</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="异位同词"><a href="#异位同词" class="headerlink" title="异位同词"></a>异位同词</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; need, window;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : t) need[c]++;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>    vector&lt;<span class="hljs-keyword">int</span>&gt; res; <span class="hljs-comment">// 记录结果</span><br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        <span class="hljs-keyword">if</span> (need.count(c)) &#123;<br>            window[c]++;<br>            <span class="hljs-keyword">if</span> (window[c] == need[c]) <br>                valid++;<br>        &#125;<br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (right - left &gt;= t.size()) &#123;<br>            <span class="hljs-comment">// 当窗口符合条件时，把起始索引加入 res</span><br>            <span class="hljs-keyword">if</span> (valid == need.size())<br>                res.push_back(left);<br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            <span class="hljs-keyword">if</span> (need.count(d)) &#123;<br>                <span class="hljs-keyword">if</span> (window[d] == need[d])<br>                    valid--;<br>                window[d]--;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="最长无重复字串"><a href="#最长无重复字串" class="headerlink" title="最长无重复字串"></a>最长无重复字串</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; window;<br><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>; <span class="hljs-comment">// 记录结果</span><br>    <span class="hljs-keyword">while</span> (right &lt; s.size()) &#123;<br>        <span class="hljs-keyword">char</span> c = s[right];<br>        right++;<br>        <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>        window[c]++;<br>        <span class="hljs-comment">// 判断左侧窗口是否要收缩</span><br>        <span class="hljs-keyword">while</span> (window[c] &gt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">char</span> d = s[left];<br>            left++;<br>            <span class="hljs-comment">// 进行窗口内数据的一系列更新</span><br>            window[d]--;<br>        &#125;<br>        <span class="hljs-comment">// 在这里更新答案</span><br>        res = max(res, right - left);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="常数时间插入、删除和获取随即元素"><a href="#常数时间插入、删除和获取随即元素" class="headerlink" title="常数时间插入、删除和获取随即元素"></a>常数时间插入、删除和获取随即元素</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomizedSet</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 存储元素的值</span><br>    vector&lt;<span class="hljs-keyword">int</span>&gt; nums;<br>    <span class="hljs-comment">// 记录每个元素对应在 nums 中的索引</span><br>    unordered_map&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; valToIndex;<br><br>    <span class="hljs-function">bool <span class="hljs-title">insert</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 若 val 已存在，不用再插入</span><br>        <span class="hljs-keyword">if</span> (valToIndex.count(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 若 val 不存在，插入到 nums 尾部，</span><br>        <span class="hljs-comment">// 并记录 val 对应的索引值</span><br>        valToIndex[val] = nums.size();<br>        nums.push_back(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function">bool <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-comment">// 若 val 不存在，不用再删除</span><br>        <span class="hljs-keyword">if</span> (!valToIndex.count(val)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-comment">// 先拿到 val 的索引</span><br>        <span class="hljs-keyword">int</span> index = valToIndex[val];<br>        <span class="hljs-comment">// 将最后一个元素对应的索引修改为 index</span><br>        valToIndex[nums.back()] = index;<br>        <span class="hljs-comment">// 交换 val 和最后一个元素</span><br>        swap(nums[index], nums.back());<br>        <span class="hljs-comment">// 在数组中删除元素 val</span><br>        nums.pop_back();<br>        <span class="hljs-comment">// 删除元素 val 对应的索引</span><br>        valToIndex.erase(val);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getRandom</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 随机获取 nums 中的一个元素</span><br>        <span class="hljs-keyword">return</span> nums[rand() % nums.size()];<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h4 id="避开黑名单的随机数"><a href="#避开黑名单的随机数" class="headerlink" title="避开黑名单的随机数"></a>避开黑名单的随机数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-keyword">int</span> sz;<br>    unordered_map&lt;<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>&gt; mapping;<br><br>    Solution(<span class="hljs-keyword">int</span> N, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; blacklist) &#123;<br>        sz = N - blacklist.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b : blacklist) &#123;<br>            mapping[b] = <span class="hljs-number">666</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> last = N - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> b : blacklist) &#123;<br>            <span class="hljs-comment">// 如果 b 已经在区间 [sz, N)</span><br>            <span class="hljs-comment">// 可以直接忽略</span><br>            <span class="hljs-keyword">if</span> (b &gt;= sz) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (mapping.count(last)) &#123;<br>                last--;<br>            &#125;<br>            mapping[b] = last;<br>            last--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">pick</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 随机选取一个索引</span><br>        <span class="hljs-keyword">int</span> index = rand() % sz;<br>        <span class="hljs-comment">// 这个索引命中了黑名单，</span><br>        <span class="hljs-comment">// 需要被映射到其他位置</span><br>        <span class="hljs-keyword">if</span> (mapping.count(index)) &#123;<br>            <span class="hljs-keyword">return</span> mapping[index];<br>        &#125;<br>        <span class="hljs-comment">// 若没命中黑名单，则直接返回</span><br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>
<h4 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">removeDuplicateLetters</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    Stack&lt;Character&gt; stk = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br><br>    <span class="hljs-comment">// 维护一个计数器记录字符串中字符的数量</span><br>    <span class="hljs-comment">// 因为输入为 ASCII 字符，大小 256 够用了</span><br>    <span class="hljs-keyword">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>        count[s.charAt(i)]++;<br>    &#125;<br><br>    <span class="hljs-keyword">boolean</span>[] inStack = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">256</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">char</span> c : s.toCharArray()) &#123;<br>        <span class="hljs-comment">// 每遍历过一个字符，都将对应的计数减一</span><br>        count[c]--;<br><br>        <span class="hljs-keyword">if</span> (inStack[c]) <span class="hljs-keyword">continue</span>;<br><br>        <span class="hljs-keyword">while</span> (!stk.isEmpty() &amp;&amp; stk.peek() &gt; c) &#123;<br>            <span class="hljs-comment">// 若之后不存在栈顶元素了，则停止 pop</span><br>            <span class="hljs-keyword">if</span> (count[stk.peek()] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">// 若之后还有，则可以 pop</span><br>            inStack[stk.pop()] = <span class="hljs-keyword">false</span>;<br>        &#125;<br>        stk.push(c);<br>        inStack[c] = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">while</span> (!stk.empty()) &#123;<br>        sb.append(stk.pop());<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.reverse().toString();<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="删除重复元素"><a href="#删除重复元素" class="headerlink" title="删除重复元素"></a>删除重复元素</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 数组</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeDuplicates</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>, fast = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != nums[slow]) &#123;<br>            slow++;<br>            <span class="hljs-comment">// 维护 nums[0..slow] 无重复</span><br>            nums[slow] = nums[fast];<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-comment">// 数组长度为索引 + 1</span><br>    <span class="hljs-keyword">return</span> slow + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">//链表</span><br><span class="hljs-function">ListNode <span class="hljs-title">deleteDuplicates</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    ListNode slow = head, fast = head;<br>    <span class="hljs-keyword">while</span> (fast != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (fast.val != slow.val) &#123;<br>            <span class="hljs-comment">// nums[slow] = nums[fast];</span><br>            slow.next = fast;<br>            <span class="hljs-comment">// slow++;</span><br>            slow = slow.next;<br>        &#125;<br>        <span class="hljs-comment">// fast++</span><br>        fast = fast.next;<br>    &#125;<br>    <span class="hljs-comment">// 断开与后面重复元素的连接</span><br>    slow.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> head;<br>&#125;<br><br><span class="hljs-comment">//移除元素</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> fast = <span class="hljs-number">0</span>, slow = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (fast &lt; nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (nums[fast] != val) &#123;<br>            nums[slow] = nums[fast];<br>            slow++;<br>        &#125;<br>        fast++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> slow;<br>&#125;<br><br><span class="hljs-comment">//移动零</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">// 去除 nums 中的所有 0</span><br>    <span class="hljs-comment">// 返回去除 0 之后的数组长度</span><br>    <span class="hljs-keyword">int</span> p = removeElement(nums, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">// 将 p 之后的所有元素赋值为 0</span><br>    <span class="hljs-keyword">for</span> (; p &lt; nums.length; p++) &#123;<br>        nums[p] = <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 见上文代码实现</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">removeElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> val)</span></span>;<br></code></pre></div></td></tr></table></figure>
<h4 id="TwoSum无序"><a href="#TwoSum无序" class="headerlink" title="TwoSum无序"></a>TwoSum无序</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    HashMap&lt;Integer, Integer&gt; index = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">// 构造一个哈希表：元素映射到相应的索引</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        index.put(nums[i], i);<br>    <br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">int</span> other = target - nums[i];<br>        <span class="hljs-comment">// 如果 other 存在且不是 nums[i] 本身</span><br>        <span class="hljs-keyword">if</span> (index.containsKey(other) &amp;&amp; index.get(other) != i)<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;i, index.get(other)&#125;;<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;-<span class="hljs-number">1</span>, -<span class="hljs-number">1</span>&#125;;<br>&#125;<br><br></code></pre></div></td></tr></table></figure>
<h2 id="二、动态规划"><a href="#二、动态规划" class="headerlink" title="二、动态规划"></a>二、动态规划</h2><h3 id="1-基本技巧"><a href="#1-基本技巧" class="headerlink" title="1. 基本技巧"></a>1. 基本技巧</h3><h3 id="凑零钱问题"><a href="#凑零钱问题" class="headerlink" title="凑零钱问题"></a>凑零钱问题</h3><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># dp[i] = x表示，当目标金额为i时，至少需要x枚硬币</span><br><span class="hljs-built_in">int</span> coinChange(vector&lt;<span class="hljs-built_in">int</span>&gt;&amp; coins, <span class="hljs-built_in">int</span> amount) &#123;<br>    // 数组大小为 amount + <span class="hljs-number">1</span>，初始值也为 amount + <span class="hljs-number">1</span><br>    vector&lt;<span class="hljs-built_in">int</span>&gt; dp(amount + <span class="hljs-number">1</span>, amount + <span class="hljs-number">1</span>);<br>    // base case<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; dp.size(); i++) &#123;<br>        // 内层 <span class="hljs-keyword">for</span> 在求所有子问题 + <span class="hljs-number">1</span> 的最小值<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> coin : coins) &#123;<br>            // 子问题无解，跳过<br>            <span class="hljs-keyword">if</span> (i - coin &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            dp[i] = <span class="hljs-built_in">min</span>(dp[i], <span class="hljs-number">1</span> + dp[i - coin]);<br>        &#125;<br>    &#125;<br>    return (dp[amount] == amount + 1) ? -1 : dp[amount];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="下降路径最小和"><a href="#下降路径最小和" class="headerlink" title="下降路径最小和"></a>下降路径最小和</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minFallingPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = matrix.length;<br>    <span class="hljs-keyword">int</span> res = Integer.MAX_VALUE;<br>    <span class="hljs-comment">// 备忘录里的值初始化为 66666</span><br>    memo = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        Arrays.fill(memo[i], <span class="hljs-number">66666</span>);<br>    &#125;<br>    <span class="hljs-comment">// 终点可能在 matrix[n-1] 的任意一列</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        res = Math.min(res, dp(matrix, n - <span class="hljs-number">1</span>, j));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-comment">// 备忘录</span><br><span class="hljs-keyword">int</span>[][] memo;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">dp</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> j)</span> </span>&#123;<br>    <span class="hljs-comment">// 1、索引合法性检查</span><br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || j &lt; <span class="hljs-number">0</span> ||<br>        i &gt;= matrix.length ||<br>        j &gt;= matrix[<span class="hljs-number">0</span>].length) &#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">99999</span>;<br>    &#125;<br>    <span class="hljs-comment">// 2、base case</span><br>    <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> matrix[<span class="hljs-number">0</span>][j];<br>    &#125;<br>    <span class="hljs-comment">// 3、查找备忘录，防止重复计算</span><br>    <span class="hljs-keyword">if</span> (memo[i][j] != <span class="hljs-number">66666</span>) &#123;<br>        <span class="hljs-keyword">return</span> memo[i][j];<br>    &#125;<br>    <span class="hljs-comment">// 进行状态转移</span><br>    memo[i][j] = matrix[i][j] + min(<br>            dp(matrix, i - <span class="hljs-number">1</span>, j), <br>            dp(matrix, i - <span class="hljs-number">1</span>, j - <span class="hljs-number">1</span>),<br>            dp(matrix, i - <span class="hljs-number">1</span>, j + <span class="hljs-number">1</span>)<br>        );<br><br>    <span class="hljs-keyword">return</span> memo[i][j];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">min</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a, <span class="hljs-keyword">int</span> b, <span class="hljs-keyword">int</span> c)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Math.min(a, Math.min(b, c));<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="最长回文子序列"><a href="#最长回文子序列" class="headerlink" title="最长回文子序列"></a>最长回文子序列</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-comment">// dp 数组全部初始化为 0</span><br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; dp(n, vector&lt;<span class="hljs-keyword">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        dp[i][i] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// 反着遍历保证正确的状态转移</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (s[i] == s[j])<br>                dp[i][j] = dp[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[i][j] = max(dp[i + <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 整个 s 的最长回文子串长度</span><br>    <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">longestPalindromeSubseq</span><span class="hljs-params">(string s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = s.size();<br>    <span class="hljs-comment">// base case：一维 dp 数组全部初始化为 1</span><br>    <span class="hljs-function">vector&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(n, <span class="hljs-number">1</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-keyword">int</span> temp = dp[j];<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (s[i] == s[j])<br>                dp[j] = pre + <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">else</span><br>                dp[j] = max(dp[j], dp[j - <span class="hljs-number">1</span>]);<br>            pre = temp;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n - <span class="hljs-number">1</span>];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h4 id="目标和"><a href="#目标和" class="headerlink" title="目标和"></a>目标和</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 回溯</span><br><span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/* 主函数 */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findTargetSumWays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    backtrack(nums, <span class="hljs-number">0</span>, target);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-comment">/* 回溯算法模板 */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, <span class="hljs-keyword">int</span> rest)</span> </span>&#123;<br>    <span class="hljs-comment">// base case</span><br>    <span class="hljs-keyword">if</span> (i == nums.length) &#123;<br>        <span class="hljs-keyword">if</span> (rest == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 说明恰好凑出 target</span><br>            result++;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">// 给 nums[i] 选择 - 号</span><br>    rest += nums[i];<br>    <span class="hljs-comment">// 穷举 nums[i + 1]</span><br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-comment">// 撤销选择</span><br>    rest -= nums[i]; <br><br>    <span class="hljs-comment">// 给 nums[i] 选择 + 号</span><br>    rest -= nums[i];<br>    <span class="hljs-comment">// 穷举 nums[i + 1]</span><br>    backtrack(nums, i + <span class="hljs-number">1</span>, rest);<br>    <span class="hljs-comment">// 撤销选择</span><br>    rest += nums[i];<br>&#125;<br><br><span class="hljs-comment">// dp</span><br><span class="hljs-comment">/* 计算 nums 中有几个子集的和为 sum */</span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">subsets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> sum)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[sum + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">// base case</span><br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-comment">// j 要从后往前遍历</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = sum; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>            <span class="hljs-comment">// 状态转移方程</span><br>            <span class="hljs-keyword">if</span> (j &gt;= nums[i-<span class="hljs-number">1</span>]) &#123;<br>                dp[j] = dp[j] + dp[j-nums[i-<span class="hljs-number">1</span>]];<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[j] = dp[j];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[sum];<br>&#125;<br></code></pre></div></td></tr></table></figure>
<h3 id="2-子序列"><a href="#2-子序列" class="headerlink" title="2. 子序列"></a>2. 子序列</h3><h3 id="3-背包"><a href="#3-背包" class="headerlink" title="3. 背包"></a>3. 背包</h3><h3 id="4-贪心"><a href="#4-贪心" class="headerlink" title="4. 贪心"></a>4. 贪心</h3><h3 id="5-玩游戏"><a href="#5-玩游戏" class="headerlink" title="5. 玩游戏"></a>5. 玩游戏</h3><h2 id="三、算法技巧"><a href="#三、算法技巧" class="headerlink" title="三、算法技巧"></a>三、算法技巧</h2><h3 id="1-暴力搜索（DFS、BFS）"><a href="#1-暴力搜索（DFS、BFS）" class="headerlink" title="1. 暴力搜索（DFS、BFS）"></a>1. 暴力搜索（DFS、BFS）</h3><h3 id="2-数学运算"><a href="#2-数学运算" class="headerlink" title="2. 数学运算"></a>2. 数学运算</h3><h3 id="3-其他技巧"><a href="#3-其他技巧" class="headerlink" title="3. 其他技巧"></a>3. 其他技巧</h3><h3 id="4-经典题"><a href="#4-经典题" class="headerlink" title="4. 经典题"></a>4. 经典题</h3><h4 id="分割数组为连续子序列"><a href="#分割数组为连续子序列" class="headerlink" title="分割数组为连续子序列"></a><strong>分割数组为连续子序列</strong></h4>
            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AE%97%E6%B3%95/">算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/10/15/%E6%9C%AA%E6%9D%A5%E7%9A%84%E8%B5%84%E4%BA%A7%E5%BA%93-Sauce/">
                        <span class="hidden-mobile">未来的资产库-Sauce</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"TGxc9YICCvt0nq9LsWQVqXIR-gzGzoHsz","appKey":"g61pWrmFa2w876qITKSoChaX","placeholder":"说点什么","path":"window.location.pathname","avatar":"retro","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://tgxc9yic.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- LeanCloud 统计PV -->
        <span id="leancloud-site-pv-container" style="display: none">
            总访问量 
            <span id="leancloud-site-pv"></span>
             次
          </span>
      
      
        <!-- LeanCloud 统计UV -->
        <span id="leancloud-site-uv-container" style="display: none">
            总访客数 
            <span id="leancloud-site-uv"></span>
             人
          </span>
      

    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>




  <script defer src="/js/leancloud.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  








  

  

  

  

  

  





<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
