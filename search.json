[{"title":"同时多线程结构上操作系统的行为分析","url":"/2021/04/11/同时多线程结构上操作系统的行为分析/","content":"作者：Joshua A. Redstone, Susan J. Eggers and Henry M. Levy University of Washington\n# 摘要\n本论文首次分析了操作系统在同步多线程(SMT)处理器上的执行情况。虽然SMT在过去六年得到了广泛的研究，但这些研究大都集中在用户模式执行上。然而，许多最适合多线程技术的应用程序都将很大一部分时间都花在内核代码上。因此，要完全理解这种工作负载的行为，需要执行和测量操作系统以及应用程序本身。\n\n为了进行这项研究，我们做了以下工作：\n1.修改Digital Unix 4.0d操作系统以运行在SMT CPU上\n2.将我们的SMT Alpha指令集模拟器集成到SimOS模拟器种以提供一个执行环境\n\n对于操作系统密集型工作负载，我们在SMT上运行多线程Apache Web服务器。我们将Apache的用户模式和内核模式行为与标准SPECInt工作负载进行了比较。总的来说，我们的结果展示了SMT处理器上操作系统密集型工作负载的微架构影响，并提供了对Apache Web服务器操作系统需求的深入了解。SMT处理器与Web和OS软件之间的协同作用产生了比以前检查过了任何工作负载（包括商业数据库和显示并行程序）上更大的吞吐量增益。\n\n# 1. 介绍\n同步多线程（SMT）是一种延迟容忍的CPU体系结构，它在每个周期中从多个线程执行多个指令。SMT的工作原理是将线程级并行转换为指令级并行，有效地将来自不同线程的指令送入大问题、无序超标标量处理器的功能单元。在过去的六年里，SMT得到了广泛的研究。康柏最近宣布Alpha 21464将包括SMT。作为一种通用的吞吐量增强机制。同步多线程特别适合于天生是多线程的应用程序，例如作为数据库和Web服务器，以及多程序和平行的科学工作负载。\n\n本文首次检查了：\n1.SMT架构上的操作系统行为\n2.Web服务器SM应用程序，对于基于服务器的环境，操作系统是工作负载的关键组件。\n以前的研究表明，数据库系统在内核中花费了30%到40%的执行事件，而我们的测量表明，Apache Web服务器在内核中花费了75%以上的时间。因此，对它们行为的任何分析都应该包括操作系统活动。\n由于几个原因，操作系统对处理器的要求比典型的用户代码更高。\n首先，操作系统是巨大的程序，由于代码和数据的大小，它们会淹没缓存和TLB。\n其次，由于频繁的分支和不频繁的循环，操作系统可能会影响分支预测性能。\n第三，操作系统的执行通常是短暂的和间歇的，由中断、异常或系统调用调用，并可能导致替换有用的缓存、TLB和分支预测状态，但好处很少或没有。\n第四，操作系统可能执行自旋等待、显式缓存/TLB失效和其他用户模式代码中不常见的操作。由于这些原因，忽略操作系统（在架构模拟中通常是这样做的）可能会导致对系统级性能的误导性描述。即使对操作系统不密集的应用程序，与操作系统执行的指令数量相比，操作系统的性能影响也可能不成比例地大。\n对于SMT，功能处理器和操作系统还不存在。相反，我们扩展了SimOS-Alpha基础设施，添加了一个基于alpha的SMT核心作为指令执行引擎。SimOS是一个模拟器，足够详细的引导和执行一个完整的操作系统，在康柏Alpha的情况下，SimOS也执行PAL代码。我们还修改了Digital Unix 4.0d操作系统以支持SMT。这种修改非常简单，因为Digital Unix的目标是在传统的共享内存处理器上运行，因为已经为多线程操作同步了。\n作为SMT环境中操作系统行为的首次研究，我们的目标是回答几个基本问题\n1.当操作系统添加到工作负载中时，以前报告的结果会发生什么变化（如果有的话）？特别是，我们希望核实之前研究的IPC结果，看看他们排除OS是否过于乐观。对于这些研究我们使用了一个由多个SPECInt基准组成的多程序工作负载。\n2.也是更重要的，操作系统密集型工作负载和传统的工作负载都执行SMT在体系结构级别上的主要行为差异是什么？例如，操作系统如何改变微体系结构级别的资源利用率，对于具有细粒度资源共享（如SMT）的处理器，它会导致什么特殊问题（如果有的话）？对于这个问题，我们研究了一个操作系统密集型的应用程序，即广泛使用的Apache Web服务器，它是由SPECWeb基准测试驱动的。我们比较了Apache工作负载和SPECInt工作负载，以研究高操作系统和低操作系统使用的擦会议。\n3.像Apache这样的Web服务器如何从SMT中获益，从软件的角度看，它将时间花在哪里？这个分析本身就很有趣，因为Web服务器和类似的应用程序越来越重要。因此我们给出了无序超标量和SMT上Apache的结果。\n总定来说，我们的结果描述了操作系统密集型工作负载的架构行为和关键应用程序（Apache Web服务器）的软件行为（在操作系统内）。\n本文组织如下。第二节详细介绍了我们的测量方法、模拟环境和我们使用的工作负载。第三节给出了我们在SMT上的两种工作负载（包括操作系统执行）的测量结果。第三节的前半部分介绍了由SPECInt应用程序组成的多编程工作负载，而后半部分主要关注Apache工作负载。第四节描述了以前的工作及其与我们研究的关系。我们在第五节做总结。\n\n\n# 2. 方法\n本节描述在我们基于模拟的实验中使用的方法。我们首先描述SMT处理器和模拟硬件配置的西结。然后，我们从硬件和软件两个层面描述操作系统仿真环境。最后，我们描述评估的两个工作负载：一个是SPECInt95基准测试的多编程工作负载；另一个是Apache Web服务器。\n## 2.1 SMT和超标量处理器模型\nSMT是一种延迟容忍的CPU体系结构，它在每个周期中执行来自多个线程的多个指令。通过线程级并行转换为指令级并行，从不同线程发出指令的能力可以更好地利用执行资源。以前的研究已经证实，SMT可以有效地提高各种工作负载上的吞吐量，同时仍然为单线程应用程序提供良好的性能。\n在硬件层面，SMT是现代无序超标量（如MIPS R10000或Alpha 21264）的直接扩展。SMT复制了一个超标量的寄存器文件、程序计数器、子程序堆栈和内部处理器寄存器，以保存多个线程的转台（我们将包含线程状态的硬件资源集称为上下文）。除了复制线程状态以外，SMT还具有用于管道刷新、指令退出、子例程返回预测和捕获的每上下文机制。康柏估计，对支持SMT所需的无序超标量进行修改，只会使芯片面积增加10%。\n表一列出了模拟的SMT处理器和存储系统的参数，这些参数使选择作为近期处理器的特性。我们评估的无序超标量提供了与SMT相同的硬件资源，除了它缺少额外的硬件上下文，并且由于它的寄存器文件更小，它有更少的两个流水线阶段。\n![表一：SMT参数](https://img-blog.csdnimg.cn/2020122014505387.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70)\n\n## 2.2 操作系统执行\n### 2.2.1 操作系统仿真环境\n在某种程度上，操作系统只是一个大程序；然而，它在访问低级硬件资源时（例如，I/O设备寄存器和内部CPU寄存器）和响应低级硬件事件（例如，异常和中断）方面是独特的。因此，要模拟操作系统，就需要模拟这些资源和事件。在本工作中，我们构建了SimOS-alpha硬件仿真框架。将我们的SMT CPU模拟器集成到SimOS中。这允许我们在模拟器上引导和运行操作系统，并在我们的模拟器中包含将在实际CPU上运行的每条指令，有特权的或无特权的。SimOS环境也执行Alpha PAL代码--存在于操作系统本身之下的一层软件。例如，PAL代码用于响应TLB丢失和处理操作系统内的同步（SETIPL）。我们还对几乎所有影响内存层次结构的操作系统/硬件交互进行建模，比如DMA操作和缓存刷新指令。一个例外是来自网络接口的DMA操作；尽管包含与网络相关的DMA将使Apache工作负载的内存总线事务数加倍（SPECInt工作负载不使用网络），但平均内存总线延迟仍然微不足道，因为它目前每个总线事务只有0.25个周期。\n我们的研究集中在CPU和内存性能瓶颈上。为了节省模拟时间，我们模拟了一个零延迟磁盘。使用大型、快速磁盘阵列子系统对机器进行建模。但是，将执行所有操作磁盘的操作系统代码，包括磁盘驱动程序和DMA操作。对磁盘绑定及其进行建模可能会改变系统行为，特别是在缓存层次结构中。\n### 2.2.2 操作系统修改\n我们执行康柏digital Unix 4.0d操作系统，这是一个（共享内存）多处理器感知的操作系统。通过允许SMT在操作系统中显示为共享内存多处理器（SMP），只需在SMT和SMP体系结构不同的地方对操作系统进行更改。在Alpha的情况下，这些差异是SMT的共享TLB和L1缓存，而Alpha SMP的每个处理器的TLB和L1缓存，而Alpha SMP的每个处理器的TLB和L1缓存。在这两种差异中，只有与tlb相关的OS代码需要修改。\nAlpha TLB在TLB条目上包含一个地址空间号（ASN）标记，它允许多个地址空间共享TLB，并减少上下文切换时的TLB刷新。由于多个线程可以同时访问SMT处理器的共享TLB，操作这些asn需要在上下文切换期间进行适当的互斥。因此，我们对tlb相关的代码做了一些更改。首先，我们修改了ASN分配算法以覆盖多个执行线程。其次，我们在每个上下文基础上复制了用于修改TLB条目的内部处理器寄存器；这样就删除了竞态条件，并允许多个上下文并行处理TLB miss。第三，我们删除了TLB击落代码，这在单处理器SMT中是不必要的。\n尽管SMT处理器和MP的缓存架构接口不同，但这并不需要对操作系统进行修改。该接口提供了刷新L1指令和数据缓存的命令，在SMT中，这会导致刷新线程共享缓存，而不是线程本地缓存。由于缓存是软状态，因此结果的额外刷新可能是不必要的，但绝对不会是错误的。\n我们执行的操作系统包含在SMT上运行Digital Unix所需的最小更改集，但没有探索大量的优化机会。例如，操作系统结构（如空闲循环和自旋锁定）是不必要的，会浪费SMT上的资源。（然而，在本文实验中，空闲周期栈稳定状态CPU比例不超过0.7%，旋转锁定在SPECInt工作负载中占不到1.2%，在Apache工作负载中占不到4.5%）。另一个可能的优化是用smt优化的调度器替换MP OS进程调度器。我们计划研究操作系统优化为未来的工作，但令人鼓舞的是，可以直接修改支持smp的操作系统，以便在SMT处理器上工作。\n## 2.3 模拟工作负载\n在这项研究中，我们检查了两种不同的工作负载。第一个是多程序工作负载，由SPEC95Int的所有8个应用程序组成，我们对该套件模拟了6.5亿条指令。选择SEPCInt95有两个原因，首先，由于它通常用于架构评估，包括SMT的研究，我们希望了解在以前的工作中没有包含OS活动遗漏了什么。其次，由于Apache也是一个interger程序，SPECInt的性能可以作为基线，帮助了解Apache的性能。\n第二个工作负载是Apache（版本1.3.4），这是一个流行的公共域Web服务器，由大多数Web站点运行。因为它大量使用OS服务（我们的测量显示75%的执行周期是在内核中度过的），所以它是一个用于检查OS性能的丰富环境（本文中介绍的大多数Apache数据都是基于对超过10亿条指令的模拟，从服务器空闲时开始）。然而，第3.2节中的超标量实验是在大约7亿条指令的模拟上进行的，受到模拟时间的限制。\n我们使用SPECWeb96驱动Apache，这是一个Web服务器性能基准测试。我们配置Apache64个服务器进行，配置了SPECWeb 128个提供请求的客户端。为了支持使Apache饱和的请求速率。为了支持使Apache饱和所需的请求速率，我们将SPECWeb基准作为两个驱动进程执行，每个驱动程序有64个客户端。如果驱动程序运行在一个本地Alpha，然后网络代码将无法正常运行，消息被TCP丢弃。因此，我们构建了一个框架，在这个框架中，我们在单个Alpha上运行三个SimOS副本。结果是SPECWeb96客户端出现了与Apache完全相同的减速。客户端以Apache可以处理的速度生成数据包，并且双方的OS代码可以正确地管理网络接口和协议。在这三个SimOS环境之间，我们模拟了一个直接的网络连接，该连接传输数据包不存在丢失和延迟。模拟的网卡以10毫秒的时间粒度中断CPU，并且网络模拟器每隔10毫秒强制跨所有机器执行屏障同步。这个屏障使模拟器保持同步运行，并保证我们实验的可重复性的模拟的确定性执行。\n### 2.3.1 只模拟应用程序代码\n为了更精确地描述操作系统对性能的影响，我们将包含操作系统工作负载模拟与之模拟应用程序代码的工作负载模拟进行了比较。仅用于应用的模拟是通过一个单独的模拟器来完成的，该模拟器源自以前SMT研究中使用的SMT模拟器。仅应用程序模拟器将所有系统调用和内核陷阱建模为立即完成，对硬件状态没有影响。\n# 3. 结果\n本节介绍基于simos的操作系统行为测量结果及其对SMT处理器的影响，在3.1节中，我们考虑一个特定的多程序工作负载；第3.2节研究了Apache工作负载，并将其与SPECInt的结果进行了比较。\n## 3.1 对SPECInt工作负载的评估\n传统上，架构师根据科学和程序开发工作负载的分析来决定处理器和内存子系统的设计，SPECInt基准套件就是典型的例子。然而，大多数这样的分析只检查用户模式代码。在本节中，我们将评估这种做法的适当性，同步多线程上下文中的方法学策略。我们希望特别回答两个问题。首先，在SMT上包括（或不包括）操作系统的影响是什么，即使对于SPECInt基准测试的多编程工作负载也是如此？虽然我们预计SPECInt的操作系统使用率较低，但之前的研究表明，忽略内核代码，即使在这样低操作系统环境中，也会导致对内存系统行为的不良估计。第二，操作系统代码对8-上下文SMT的影响与无序超标量的影响相比如何？SMT的独特之处在于它同时执行内核模式和用户模式指令。也就是说，在一个周期中，来自多个内核例程的指令可以与来自多个用户应用程序的指令一起执行，而所有这些指令都共享一个内存层次结构。相反，超标量可以将来自单个应用程序的用户指令长流与来自单个内核服务的内核指令长流交替使用。在两种体系结构中，这种差异可能会对内存系统性能产生不同的银杏果i昂。在3.2节中，我们将根据Apache（一种操作系统更密集的工作负载）研究类似的问题。\n### 3.1.1 传统的SPEC interger工作负载在SMT处理器上执行的OS行为\n图一显示了多程序SPECInt95基准测试的执行周期百分比，这些基准测试占用用户空间、内核空间，或者在SMT处理器上执行时空闲。在程序启动期间（如图虚线左侧所示），操作系统平均占执行周期的18%，一旦达到稳定状态，它就会下降到相当稳定的5%，在执行过程中至少要维持16亿次循环（图中只显示了一部分）。在程序初始化较高的OS活动主要是由于TLB未处理（占所有 执行周期的12%）和系统调用5%，如图二所示。大多数TLB活动集中在处理TLB在用户空间丢失的数据（大约95%）。TLB错过了对内核内存管理的调用，而页面分配占据了这些调用的大部分，如图三所示。大多数由应用程序发起的系统调用是针对文件系统的；特别是，读取输入文件占用3.5%的执行周期，这与读取源和/或配置文件的应用程序一致。进程创建和控制以及内核前导（识别并分派到特定的系统调用）占用了大部分剩余的系统调用时间。注意，内核活动使Alpha PAL代码的执行相形见绌。\n一旦达到稳定状态，内核活动将下降到执行周期的5%，但是TLB处理和系统调用时间的比例与启动期间大致相同。唯一重要的变化是文件读取调用的减少，因为程序已经从初始化转向。\n表2显示了内核中各主要指令类别的指令分布情况；这些值是证书应用程序的典型值，包括SPEC整数基准测试。内核指令与用户指令在三个方面不同，首先，大约一半的内存操作在程序启动时，三分之一的负载和三分之二的存储处于稳定状态，不适用TLB，即TLB。它们直接指定物理地址。其次，内核控制传输包括PAL入口/返回分支。第三，与用户代码相比，稳态内核代码的条件分支占有率只有用户代码的一般。但是，由于内核执行时间很少，所以这些差异的总体影响很小。\n\n![图一 SPECInt95在SMT上执行的执行周期分解，在内核中花费的周期占所有执行周期的百分比在顶部黑色部分](https://img-blog.csdnimg.cn/20201223203038244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![图2：SPECInt的内核时间分解](https://img-blog.csdnimg.cn/20201223182106203.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n\n![图3：内存内核管理代码](https://img-blog.csdnimg.cn/20201223122255824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![图4：系统调用占总执行的百分比](https://img-blog.csdnimg.cn/2020122312230790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![表2：按指令类型分列的动态指令在SPECInt工作负载中的百分比，内存操作的括号中的百分比表示加载和存储的物理地址的比例。还包括分支指令的百分比细分，对于条件分支，括号中的数字表示所采用的条件分支的百分比](https://img-blog.csdnimg.cn/20201223122319240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n\n### 3.1.2 为什么要在特定的工作负载上模拟操作系统\n表3上半部分显示了在SMT上模拟SPECInt95和操作系统时，几种硬件数据结构中的未命中率。总的结果反映了其他研究人员在单线程处理器研究中发现的情况，即操作系统表现出的性能比特殊应用程序要差。分支目标缓冲器的内核未命中率特别高，因为两个因素：操作系统执行其实很少，无法建立一个持久的分支目标状态；大多数内核未命中（78%）取代其他内核条目错误是由于重复的变化间跳转的目标地址。\n表3下半部分的分布结果表明，除指令缓存外，应用程序线程内部或应用程序线程之间的冲突是造成绝大多数缺失的原因。内核引起的冲突缺失仅占BTB缺失的10%，数据缓存缺失的18%，L2缓存缺失的9%和数据TLB缺失的18%，相比之下，大多数指令缓存丢失（60%）是由内核引起的。强制缺失对于所有硬件结构都是微不足道的，除了L2缓存，在L2缓存中内核为应用程序预取数据，因此吸收了许多第一次引用缺失的成本。\n在较高的层次上，多编程SPECInt工作负载的内核执行频率较低可以改善内核特定于硬件组件的性能，表4通过比较在SMT上有操作系统活动和没有操作系统活动时以稳定状态执行的SPECInt工作负载的几个体系结构度量，说明了这种影响。这些数字表明，指令吞吐量仅略有下降，原因是操作系统，除了少数例外，线程共享硬件资源利用率在包含内核时略有下降。我们观察到性能下降百分比较大的那些硬件组件并没有对性能底线造成很大影响，因为它们最初并没有表现出特别糟糕的行为。\n最严重的变化是模拟内核造成的，依赖于fetch引擎的两个部分，分支预测硬件和指令缓存之间的交互。转移错误预测增加了15%，指令缓存丢失增加了1.9倍，很大程度上是由于内核执行的干扰。指令丢失主要是由指令页重映射引起的缓存刷新引起的，而不是由特定缓存位置的冲突引起的，指令缺失的增加反过来导致可获取上下文的数量减少的8%，例如，那些不为指令丢失或中断服务的上下文，由于模拟器内核减少了可取上下文的平均数量，因此选择了一个预测错误的上下文来更频繁地获取数据，从而获得更多错误路径指令。\n令人惊讶的是，内核比SPECInt应用程序有更好的转移预测，尽管它缺乏基于循环的代码（当同时执行这两个操作时，用户代码中的错误率是9.3），内核代码中的大多数条件分支都用于菱形控件，在这种控件中，目标代码执行异常条件。虽然内核BTB漏失率很高，但是对一个漏失的默认预测执行直通代码，因此更多的内核预测往往是正确的。\n综上所述，尽管内核内存子系统的转移预测漏失率很高，但SMT指令吞吐量仅受到轻微影响，因为SPECInt程序中的内核活动很小，SMT很好地隐藏了延迟，因此，对类似特殊科学应用的SMT基本性能感兴趣的研究人员可以放心地依赖于应用及模拟。然而，如果专注于特定硬件组件（比如数据TLB）的设计，或者特定硬件策略（比如推测何时取数据）的设计，那么包括操作系统的执行时间影响是很重要的。![表3：在SMT上模拟SPECInt95和操作系统时，在几种硬件数据结构种总的缺失率和缺失分布，缺失类别是所有用户内核缺失的百分比。粗体条目表示内核诱导干扰。用户内核冲突是指用户线程与某种类型的内核活动冲突](https://img-blog.csdnimg.cn/20201223122337781.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![表4：带有SMT和超标量的操作系统和不带操作系统的SPECInt95的体系结构度量](https://img-blog.csdnimg.cn/20201223122347629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n\n### 3.1.3 在评估大问题超标量模型时是否应该模拟操作系统？\n就总体执行周期而言，在执行SPECInt基准测试时，操作系统在无序超标量和SMT处理器上的行为类似。超标量处理器只花费稍微大一点的执行部分在操作系统中。对于两个处理器，处于稳定状态的操作系统周期的百分比是相同的。\n同样，在超标量处理器和SMT处理器，在启动和稳定状态下OS周期的分布都类似。一个例外是超标量处理器数据TLB的内核缺失所花费的较大部分时间。而且，DTLB丢失的内核处理会显示出糟糕的指令缓存行为，这增加了花费在这段代码中的时间。内核指令缓存在超标量上的丢失率是13.8%，其中81%的丢失是由于内核DTLB错误处理代码造成的。\n在微架构级别上，操作系统在无序超标量上扮演不同的角色。超标量上的指令吞吐量大约是SMT的一半，如表4所示。尽管超标量硬件数据结构中的缺失较少发生，因为一次只执行一个线程，但超标量缺乏SMT隐藏延迟的能力。在过去对非os工作负载的SMT的所有研究中，SMT延迟容错超过了内存子系统和分支硬件中额外的线程间的冲突的补偿，最明显的是操作系统缺乏超标量的延迟隐藏能力，在稳定状态下只能达到0.6IPC，相比之下，用户代码的IPC为3.0。此外，超标量按比例压缩的指令数量大约是SMT的两倍，因为超标量只有一个要获取的指令源。\n总是，包括操作系统在SPECInt超标量体系结构模拟负载扰动底线性能超过SMT，因为超标量体系结构性能更容易受到指令延迟（在其他硬件组件中，性能下降幅度较小，或者反映了先前性能良好的组件的大幅退化）。这一结果表明，研究人员在评估超标量系统结构时，不应该对忽略操作系统的影响抱有信心。\n\n## 3.2 对Apache（一个操作系统密集型工作负载）的评估\nApache是部署最广泛的Web服务器。它的作用很简单：响应客户端HTTP请求包，通常返回请求的HTML或其他对象。对象存储在面向文件的数据库中，如果没有缓存在服务器的内存中，则从磁盘读取。下面我们将检查基于apache的工作负载。\n### 3.2.1 操作系统在执行Apache时的作用\n图五展示了Apache工作负载在SMT上执行的内核和用户活动，这些数据在几个方面与SPECInt多道程序工作负载有显著的不同，首先，Apache起步时间短；这不奇怪，因为Apache的启动只是简单地接收第一个传入的请求并唤醒服务器线程。其次，一旦请求到达，我们看到Apache花费超过75%的时间在操作系统上，即，Apache的大部分执行是在操作系统中，而不是在应用程序代码中。\n图六显示了Apache内核周期的分解，与SPECInt启动期和稳定状态期比较。对Apache来说，其内核时间的大部分都花在了执行系统调用上。也就是说，SPECInt工作负载由隐式操作系统使用主导，而Apache则更显式地使用操作系统。Apache还显示了通过网络中断的重要内核活动--SPECInt工作负载中没有响应活动，Apache花费了34%的内核周期在neister线程中处理中断请求或响应网络中断，neister线程是一组相同的线程，负责代表到达的消息管理网络协议栈。Apache中只有少量的内核活动是由于DTLB失误造成的，相比之下，SPECInt工作负载大部分内核时间与TLB丢失处理有关（稳定状态为82%，启动时为58%）\n图7显示了Apache系统调用更详细的分解。在左边，我们看到由Apache执行的每个系统调用引起的执行周期的百分比。如果所示，大部分时间花在处理对I/O例程的调用上：例如，Apache在star例程（查询文件信息）中花费了10%的周期，在读/写中花费了19%的周期，在I/O控制操作（如打开）中花费10%的周期，图7的右侧显示了相同数据的不同细分。在这里，我们根据资源类型（网络或文件）以及操作类型限定执行时间。从图中我们可以看出，网络读/写是最大的时间消耗者，大约占所有周期的17%，占Apache内核周期的22%。如上所述，文件查询（star例程）是第二大消耗者，其次是文件控制操作，占所有周期6%，占内核周期的8%。总的来说，花费在网络和文件系统的系统调用上的时间几乎与network相同服务占所有内核周期的21%，文件服务占18%。\n![图五：在SMT上执行的Apache中的内核和用户活动](https://img-blog.csdnimg.cn/20201223122411242.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![图六：在SMT上Apache内核活动分解，SPECInt工作负载的启动阶段和稳定阶段被包括进来比较](https://img-blog.csdnimg.cn/20201223122421736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![图7：在SMT处理器上处理内核系统调用所花费的执行时间分解](https://img-blog.csdnimg.cn/20201223122432279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n\n### 3.2.2 结构性能特点\n表5显示了Apache中内核和用户代码的指令类型细分。总体来说，这类似于相应的SPECInt表。Apache的稳定加载/存储百分比更接近SPECInt的启动加载/存储百分比。因为SPECInt的启动包括各种OS服务，而稳定状态SPECInt工作负载主要由tlb处理条例控制。总的来说，Apache中大约一半的内核内存访问操作绕过TLB，即，它们直接指定物理地址。\n表6展示了Apache的架构性能特征，并将它们与稳定状态下的SPECInt工作负载进行了比较，该图还显示了运行在超标量上的Apache的统计信息。Apache工作负载在SMT上实现了每个周期4.6条指令的吞吐量（最多为6条），比SPECInt工作负载低18%，性能下降的原因分布在大多数主要硬件组件中，Apache的性能比SPECInt差得多。除了数据TLB之外，内存子系统的所有组件都经历了更多的冲突；例如Apache的L2 miss率是SPECInt的1.5倍，D-cache miss率是2.3倍，I-cache miss率是2.5倍。\n与SPECInt相比，Apache在fetch单元也表现得更差，Apache的可获取上下文平均比SPECInt少20%，被压缩的指令更多。在充分利用6个缺失插槽的情况下，Apache也减少了33%的周期。然而，尽管内存和获取系统行为有这些巨大的差异，SMT仍然能很好地容忍延迟，通过处理更多的缺失，并与要求更高的工作负载并行（最后三行）。\nSMT在Apache中隐藏延迟的能力导致平均指令吞吐量为4.6IPC--是标准吞吐量的4.2倍，并且是SMT研究的任何工作负载的最高相对增益。超标量处理器实现的IPC仅为1.1--仅为SPECInt的42%（相比之下，在SMT处理器上Apache的IPC是它为SPECInt实现的82%。）最能说明性能差异的是，超标量在超过60%的周期内无法获取或发出指令，并且由于分支错误预测，它将获得的指令的46%删除了。SMT压缩的指令更少，因为多线程减少了错误预测的分支路径在条件解决之前执行的距离。\n![表5：按指令类型执行Apache时动态指令的百分比](https://img-blog.csdnimg.cn/20201223122454416.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![表6：比较在SMT上执行的Apache、在SMT上执行的SPECInt95以及在超标量上执行的Apache的体系结构指标](https://img-blog.csdnimg.cn/2020122312250543.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n\n### 3.2.3 线程间的竞争与合作\n如前所述，SMT可以在单个周期中发出来自多个内核线程的指令，这就为线程间冲突创造了新的可能性，表7给出了Apache miss行为了更多细节，重点关注冲突的原因。与SPECInt工作负载相比，最引人注目的是内核/内核和用户/内核冲突，用粗体显示。Apache中缓存丢失的最高原因是内核内部的冲突：65%的L1 Icache丢失，65%的L1 Dcache丢失，以及41%的L2缓存丢失是由于线程内或线程间的内核冲突造成的。除L2缓存之外，这两类缓存中的内核线程缺失几乎是线程内缺失的两倍。用户/内核冲突也是非常重要的：25%的L1 Icache丢失，10%的L1 Dcahce丢失，22%的L2缓存丢失是由于内核和用户代码或数据之间的冲突造成的。\n在SMT上同时运行多个内核线程的影响还可以通过将其与超标量进行比较来观察，超标量中一次只能活动一个内核线程。在Apache（未显示数据）的超标量执行中，与SMT上的Apache相比，Icache、Dcache和L2缓存中由于内核线程间冲突而导致的丢失百分比分别要低24%、28%和38%\n在BTB中，内核线程内冲突占主导地位，占所有BTB丢失的68%，而6%的丢失是由用户/引起的内核冲突。相反，用户代码要为两个TLB中的大部分丢失负责（53%的数据TLB丢失和86%的指令TLB丢失是由于用户/用户冲突造成的）。尽管用户代码只占执行周期的22%。\n虽然上面提到的数据涉及冲突，但同时执行线程也可能导致建设性的线程间行为。具体来说，当一个线程接触到即将被第二个线程访问的数据时，就会发生预取；然后第二个线程将在缓存中找到数据，从而避免丢失数据。比较SMT上这种构造共享的数量和超标量上相同的行为是很有趣的。由于SMT上有更细粒度的并行性，因此这种预取活动有更多机会。表8显示了集中资源由于在Apache中进行建设性共享而避免丢失的百分比。例如，在SMT上，如果不是内核中也在执行的其他线程预加载一个内核线程的指令，L1 Icache的总体缺失率将会更高66%。相比之下，这种共享对运行Apache的超标量的影响只有28%。同样，差异是由于SMT同时执行多个内核线程，或者在比超标量上执行的更短的时间内执行。\n对于L2缓存来说，内核-内核预取的影响甚至更大，在L2缓存中，避免了额外71%的丢失，12%的内核TLB失误也被避免了。\n![表7：在SMT上模拟Apache和操作系统时，几种硬件数据结构的缺失分布](https://img-blog.csdnimg.cn/20201223122518707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n![表8：Apache上由于线程间合作而避免缺失的百分比](https://img-blog.csdnimg.cn/20201223122630240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n\n### 3.2.4 操作系统对硬件的影响\n与前面对SPECInt工作负载的分析类似，我们现在研究操作系统对缓存和转移预测硬件的影响。操作系统增加了所有硬件结构的冲突，从L1数据丢失率增加35%到L1指令丢失率增加超过5倍不等。这些增长大致对应表7的冲突缺失数据，即，由于内核引用的增加，硬件结构中的用户丢失率降低的程度大致与内核冲突导致的用户丢失比例成正比。\n除了超标量指令缓存丢失率外，操作系统对硬件结构的影响更大，在SPECInt工作负载上执行Apache比在SPECInt工作负载上执行更少。出现这种差异主要是因为操作系统活动主导Apache的执行，但也因为它们更多样化，因此比SPECInt所需的地方更少（Apache工作负载执行各种OS服务，而SPECInt主要使用内存管理）。\n![表9：操作系统对特定硬件结构的影响](https://img-blog.csdnimg.cn/20201223122642688.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2MjMzMzQw,size_16,color_FFFFFF,t_70#pic_center)\n\n## 3.3 结果总结\n在本节中，我们测量和分析了SMT处理器的性能，包括其操作系统对于Apache Web服务器和多程序SPECInt工作负载的性能。我们的结果表明，对于SMT，操作系统的遗漏不会导致SPECInt的性能严重错误预测，尽管对于执行相同工作负载的超标量的影响更为显著。然而，在Apache工作负载上，操作系统负责执行大部分指令。Apache在响应文件系统和内核网络代码中的系统服务上花费了大量时间，大量执行OS代码的结果是增加了更重底层资源的压力，包括缓存和BTB。内核线程也会在这些资源中引起更多的冲突，包括与其他内核线程和用户线程的冲突；另一方面，也有线程间共享的效果。Apache给处理器带来了挑战性，这可以从它在超标量上的极低吞吐量（1.1IPC）看出。SMT能够隐藏Apache的大部分延迟，使其能够实现相对于超标量处理器的4.2倍速的吞吐量改进。\n\n# 4 结论\n在这篇文章中，我们报告了在一个同步多线程处理器上执行操作系统的第一次测量。对于这些测量，我们修改了康柏/DEC Unix 4.0d操作系统以在SMT CPU上执行，并通过将SMT指令级模拟器集成到Alpha SimOS环境中来执行操作系统及其应用程序。结果表明\n1.对于SEPCInt95工作负载，模拟操作系统不会显著影响SMT的总体性能，尽管操作系统的执行会对超标量产生影响。\n2.Apache大部分时间都花在操作系统内核上，执行文件系统和网络操作。\n3.Apache os密集型的工作负载对处理器来说压力很大，与SPECInt相比，这会导致缓存丢失率显著增加。\n4.从我们对冲突缺失的详细分析来看，SMT上的内核线程之间存在显著的干扰，因为SMT可以同时执行来自多个内核线程的指令。另一方面，存在从合作共享中获益的机会，正如我们在线程间预取分析中所展示的那样。\n5.总的来说，操作系统代码在超标量上导致较差的指令吞吐量，这对Apache Web服务器有很大的影响，它的IPC仅为1.1。\n6.SMT的延迟容忍能够补偿操作系统代码的许多要求，在执行Apache时，SMT的吞吐量比超标量高了四倍，这是迄今为止SMT工作负载的最高相对收益。\n最后，我们展示了将支持SMP的操作系统修改为在同步多线程处理器上执行相对简单。未来，我们打算对操作系统结构进行实验，以优化操作系统以适应SMT的特殊特性。\n","categories":["阅读"]},{"title":"大数运算","url":"/2021/04/11/大数运算/","content":"\n高精度整数：使用vector/数组存储每一位数字\n\n高精度加法/乘法：模拟加法和乘法的过程\n\n示例：\n\n```c++\n//加法\nvector<int> add(vector<int> n, vector<int> m) {\n    if (n.size() < m.size()) {\n        vector<int> temp = n;\n        n = m;\n        m = temp;\n        temp.clear();\n    } \n    \n    for (vector<int>::size_type i = 0; i != m.size(); i++) {\n        n[i] += m[i];\n    }\n    \n    for (vector<int>::size_type i = 0; i != n.size(); i++) {\n        if (n[i] > 9) {\n            n[i] %= 10;\n            n[i + 1]++;\n        }\n    }\n    if (n[n.size() - 1] > 9) {\n        n[n.size() - 1] %= 10;\n        n.push_back(1);\n    }\n    m.clear();\n    return n;\n}\n```\n\n","categories":["算法题解"]},{"title":"第八章 线性时间排序","url":"/2021/04/10/第八章 线性时间排序/","content":"\n归并排序、堆排序、快速排序各元素的次序依赖于它们之间的比较，称为比较排序。\n\n## 排序算法的下界\n\n**决策树模型**\n\n一个完全二叉树，可以表示在给定输入规模情况下，某一特定排序算法对所有元素的比较操作\n\n![image-20210331154245815](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210331154254.png)\n\n\n\n**最坏情况的下界**\n\n在决策树中，从根节点到任意一个可达叶结点之间的最长简单路径长度，表示的是对应的排序算法中最坏情况下的比较次数。\n\n定理：在最坏情况下，任何比较排序算法都需要做$\\Omega(n\\lg n)$次比较\n\n\n\n排序的稳定性：相等元素排序前后顺序不变\n\n稳定：插入排序、归并排序\n\n不稳定：堆排序、快速排序\n\n\n\n## 计数排序\n\nn个0到k的输入元素，k=O(n)时，运行时间$\\Theta(n)$\n\n每输入一个元素x，确定小于x的元素个数，从而找到其在输出数组中的位置\n\n伪代码如下：\n\n```\nCOUNTING-SORT(A,B,k)\n\tlet C[0...k] be a new array\n\tfor i = 0 to k\n\t\tC[i] = 0\n    for j = 1 to A.length\n    \tC[A[j]] = C[A[j]] + 1\n    // C[i] now contains the number of elements equal to i\n    for i = 1 to k\n    \tC[i] = C[i] + C[i-1]\n    // C[i] now contains the number of elements less or equal to i\n    for j = A.lenght downto 1\n    // 这里不太理解为什么要从后往前，从前往后应该不会影响结果\n    \tB[C[A[j]]] = A[j]\n    \tC[A[j]] = C[A[j]] - 1\n```\n\njava程序及运行结果\n\n```java\npublic static void main(String[] args) {\n    int k = 20;\n    int[] A = new int[30];\n    int[] B = new int[30];\n    for (int i = 0; i < 30; i++) {\n        A[i] = (int)(Math.random()*k);\n    }\n    countingsort(A, B, k);\n    System.out.println(Arrays.toString(A));\n    System.out.println(Arrays.toString(B));\n\n}\n\npublic static void countingsort(int[] A, int[] B, int k) {\n    int[] C = new int[k];\n    for (int j = 0; j < A.length; j++) {\n        C[A[j]] = C[A[j]] + 1;\n    }\n    for (int i = 1; i < k; i++) {\n        C[i] += C[i - 1];\n    }\n    for (int i = A.length - 1; i >= 0; i--) {\n        B[C[A[i]] - 1] = A[i];\n        C[A[i]] = C[A[i]] - 1;\n    }\n}\n```\n\n运行结果：\n\n![image-20210410135115533](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210410135122.png)\n\n\n\n## 基数排序\n\n一种用在卡片排序机上的算法\n\n```\nRADIX-SORT(A,d)\n\tfor i = 1 to d\n\t\tuse a stable sort to sort array A on digit i\n```\n\n\n\n## 桶排序\n\n将[0,1)区间划分为n个相同大小的子区间，或称为桶，然后将n个输入数分别放到各个桶中，然后，将n个输入数分别放到各个桶中。先对各个桶中的数进行排序，然后遍历每个桶，按照次序把各个桶中的元素列出来即可。（需要元素是均匀分布的，防止一个桶里面的元素太多）\n\n![image-20210410135732520](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210410135732.png)\n\n\n\n","categories":["算法导论"]},{"title":"第9章 中位数和顺序统计量","url":"/2021/04/10/第9章-中位数和顺序统计量/","content":"\n## 最小值和最大值\n\n为了确定最小值/最大值，必须要进行n-1次比较\n\n同时找到最大值/最小值，总的比较次数为至多是$3\\lfloor n/2\\rfloor$\n\n方法：对输入元素成对处理，大的和最大值比，小的和最小值比\n\n\n\n## 期望为线性时间的选择算法\n\n返回数组A[p,r]中第i小的元素\n\n```\nRANDOMIZED-SELECT (A,p,r,i)\nif p == r\n\treturn A[p]\nq = RANDOMIZED-PARTITION (A,p,r)\nk = q - p + 1\nif i == k\n\treturn A[q]\nelse if i < k\n\treturn RANDOMIZED-SELECT (A,p,q-1,i)\nelse return RANDOMIZED-SELECT (A,q+1,r,i-k)\n```\n\n\n\n## 最坏情况为线性时间的选择算法\n\n1. 将输入数组的n个元素划分为$\\lceil n/5\\rceil$组，每组5个元素，且至多只有一组由剩下的不足5个元素组成。\n2. 寻找这$\\lceil n/5\\rceil$组中每一组的中位数，首先对每组元素进行插入排序，然后确定每组有序元素中位数。\n3. 对第2步找出的$\\lceil n/5\\rceil$个中位数，递归调用SELECT以找出其中位数x（如果有偶数个中位数，为了方便，约定x是较小的数）\n4. 利用修改过的PARTITION版本，递归调用SELECT以找出其中位数x对输入数组进行划分。让k比划分的低区中的元素数目多1，因此x是第k小的元素，并且有n-k个元素在划分的高区。\n5. 如果i=k，则返回x，如果i<k，则在低区递归调用SELECT来找出第i小的元素。如果i>k，则在高区递归查找第i-k小的元素。\n\n![image-20210410140135127](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210410140135.png)","categories":["算法导论"]},{"title":"系统设计","url":"/2021/04/09/系统设计/","content":"\n## Spring\n\n*什么是Spring框架？*\n\n一种轻量级开发框架，是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。包括核心容器、数据访问/继承、Web、AOP(面向切面编程)、工具、消息和测试模块。\n\n![image-20210406142220423](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210406142220.png)\n\n- **Spring Core：** 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。\n- **Spring Aspects** ： 该模块为与AspectJ的集成提供支持。\n- **Spring AOP** ：提供了面向切面的编程实现。\n- **Spring JDBC** : Java数据库连接。\n- **Spring JMS** ：Java消息服务。\n- **Spring ORM** : 用于支持Hibernate等ORM工具。\n- **Spring Web** : 为创建Web应用程序提供支持。\n- **Spring Test** : 提供了对 JUnit 和 TestNG 测试的支持\n\n\n\n*@RestController vs @Controller* //TODO\n\n\n\n*谈谈自己对Spring IoC和AOP的理解*\n\nIoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。\n\n将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的,这大大增加了项目的可维护性且降低了开发难度。\n\n![image-20210406144124915](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210406144124.png)\n\n\n\n*Spring bean是什么？*\n\nSpring Bean是被实例的，组装的及被Spring 容器管理的Java对象。\n\nSpring 容器会自动完成@bean对象的实例化。\n\n创建应用对象之间的协作关系的行为称为：装配(wiring)，这就是依赖注入的本质。\n\n\n\n*Spring bean的作用域？*\n\n- singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。\n- prototype : 每次请求都会创建一个新的 bean 实例。\n- request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。\n- session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。\n- global-session： 全局session作用域，仅仅在基于portlet的web应用中才有意义，Spring5已经没有了。Portlet是能够生成语义代码(例如：HTML)片段的小型Java Web插件。它们基于portlet容器，可以像servlet一样处理HTTP请求。但是，与 servlet 不同，每个 portlet 都有不同的会话。\n\n\n\n*Spring Bean的生命周期？*\n\n![image-20210409134832572](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210409134832.png)\n\n\n\n*@Bean和@Component区别？*\n\n1. 作用对象不同: `@Component` 注解作用于类，而`@Bean`注解作用于方法。\n2. `@Component`通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 `@ComponentScan` 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。`@Bean` 注解通常是我们在标有该注解的方法中定义产生这个 bean,`@Bean`告诉了Spring这是某个类的示例，当我需要用它的时候还给我。\n3. `@Bean` 注解比 `Component` 注解的自定义性更强，而且很多地方我们只能通过 `@Bean` 注解来注册bean。比如当我们引用第三方库中的类需要装配到 `Spring`容器时，则只能通过 `@Bean`来实现。\n\n\n\n*说说自己对于Spring MVC的了解？*\n\nMVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。\n\n![image-20210406144822186](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210406144822.png)\n\n\n\n*SpringMVC工作原理？*\n\n1. 客户端（浏览器）发送请求，直接请求到 `DispatcherServlet`。\n2. `DispatcherServlet` 根据请求信息调用 `HandlerMapping`，解析请求对应的 `Handler`。\n3. 解析到对应的 `Handler`（也就是我们平常说的 `Controller` 控制器）后，开始由 `HandlerAdapter` 适配器处理。\n4. `HandlerAdapter` 会根据 `Handler `来调用真正的处理器来处理请求，并处理相应的业务逻辑。\n5. 处理器处理完业务后，会返回一个 `ModelAndView` 对象，`Model` 是返回的数据对象，`View` 是个逻辑上的 `View`。\n6. `ViewResolver` 会根据逻辑 `View` 查找实际的 `View`。\n7. `DispaterServlet` 把返回的 `Model` 传给 `View`（视图渲染）。\n8. 把 `View` 返回给请求者（浏览器）\n\n\n\n","categories":["面试题"]},{"title":"操作系统","url":"/2021/04/09/操作系统/","content":"\n*什么是操作系统？*\n\n操作系统是管理计算机硬件与软件资源的程序，屏蔽了硬件层了复杂性，操作系统的内核（Kernel）是操作系统的核心部分，它负责系统的内存管理，硬件设备的管理，文件系统的管理以及应用程序的管理。 内核是连接应用程序和硬件的桥梁，决定着系统的性能和稳定性。\n\n\n\n*系统调用？*\n\n我们运行的程序基本上都是在用户态，如果调用操作系统提供的系统态级别的子功能则需要系统调用。主要有：\n\n- 设备管理。完成设备的请求或释放，以及设备启动等功能。\n- 文件管理。完成文件的读、写、创建及删除等功能。\n- 进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。\n- 进程通信。完成进程之间的消息传递或信号传递等功能。\n- 内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。\n\n\n\n*进程状态？*\n\n和线程类似，有5种状态\n\n- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。\n- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。\n- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。\n- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。\n- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。\n\n\n\n*进程间通信方式？*\n\n1. **管道/匿名管道(Pipes)** ：用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。\n2. **有名管道(Names Pipes)** : 匿名管道由于没有名字，只能用于亲缘关系的进程间通信。为了克服这个缺点，提出了有名管道。有名管道严格遵循**先进先出(first in first out)**。有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。\n3. **信号(Signal)** ：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；\n4. **消息队列(Message Queuing)** ：消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。管道和消息队列的通信数据都是先进先出的原则。与管道（无名管道：只存在于内存中的文件；命名管道：存在于实际的磁盘介质或者文件系统）不同的是消息队列存放在内核中，只有在内核重启(即，操作系统重启)或者显示地删除一个消息队列时，该消息队列才会被真正的删除。消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取,比 FIFO 更有优势。\n5. **信号量(Semaphores)** ：信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。\n6. **共享内存(Shared memory)** ：使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。\n7. **套接字(Sockets)** : 此方法主要用于在客户端和服务器之间通过网络进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。\n\n\n\n*进程调度算法？*\n\n先到先服务，短作业优先，时间片轮转，多级反馈队列，优先级调度。\n\n\n\n*内存管理机制？*\n\n分为连续管理（块式管理）和非连续管理（页式管理、段式管理、段页式管理）\n\n块式管理将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块，如果程序运行只需要很小的空间的话，分配的这块内存很大一部分几乎被浪费了。这些在每个块中未被利用的空间，我们称之为碎片。\n\n页式管理把主存分为大小相等且固定的一页一页的形式，页较小，相对相比于块式管理的划分力度更大，提高了内存利用率，减少了碎片。页式管理通过页表对应逻辑地址和物理地址。\n\n段式管理把主存分为一段段的，大小不固定，每一段的空间比一页的空间小很多 。但是，最重要的是段是有实际意义的，每个段定义了一组逻辑信息，例如,有主程序段 MAIN、子程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。\n\n段页式管理机制就是把主存先分成若干段，每个段又分成若干页。\n\n\n\n*快表和多级页表？*\n\n快表是为了提高虚拟地址到物理地址的转换速度。我们可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。\n\n1. 根据虚拟地址中的页号查快表；\n2. 如果该页在快表中，直接从快表中读取相应的物理地址；\n3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；\n4. 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。\n\n引入多级页表的主要目的是为了避免把全部页表一直放在内存中占用过多空间，特别是那些根本就不需要的页表就不需要保留在内存中。\n\n\n\n*逻辑地址和物理地址？*\n\n我们编程一般只有可能和逻辑地址打交道，比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址。\n\n\n\n*CPU虚拟寻址？*\n\n使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。实际上完成虚拟地址转换为物理地址转换的硬件是 CPU 中含有一个被称为 内存管理单元（Memory Management Unit, MMU）的硬件。\n\n\n\n*虚拟内存？*\n\n**虚拟内存**是计算机系统内存管理的一种技术，我们可以手动设置自己电脑的虚拟内存。不要单纯认为虚拟内存只是“使用硬盘空间来扩展内存“的技术。**虚拟内存的重要意义是它定义了一个连续的虚拟地址空间**，并且 **把内存扩展到硬盘空间**。\n\n**虚拟内存** 使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。与没有使用虚拟内存技术的系统相比，使用这种技术的系统使得大型程序的编写变得更容易，对真正的物理内存（例如 RAM）的使用也更有效率。目前，大多数操作系统都使用了虚拟内存，如 Windows 家族的“虚拟内存”；Linux 的“交换空间”等。\n\n\n\n*局部性原理？*\n\n某个较短的时间段内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。时间局部性和空间局部性。\n\n\n\n*虚拟内存实现 ？*\n\n1. 请求分页存储管理 ：建立在分页管理之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。假如在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统也可以将暂时不用的页面置换到外存中。\n2. 请求分段存储管理：建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段储存管理方式就如同请求分页储存管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段。\n3. 请求段页式存储管理\n\n\n\n*请求分页和分页存储？*\n\n请求分页存储管理建立在分页管理之上。他们的根本区别是是否将程序全部所需的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因，我们在上面已经分析过了。\n\n它们之间的根本区别在于是否将一作业的全部地址空间同时装入主存。请求分页存储管理不要求将作业全部地址空间同时装入主存。基于这一点，请求分页存储管理可以提供虚存，而分页存储管理却不能提供虚存。\n\n不管是上面那种实现方式，我们一般都需要：\n\n1. 一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了；\n2. **缺页中断**：如果**需执行的指令或访问的数据尚未在内存**（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段**调入到内存**，然后继续执行程序；\n3. **虚拟地址空间** ：逻辑地址到物理地址的变换。\n\n\n\n*页面置换算法？*\n\n- OPT最佳页面置换算法\n- FIFO先进先出页面置换算法\n- LRU最近最久未使用页面置换算法\n- LFU最少使用页面置换算法\n\n\n\n## Linux相关\n\nLinux是一套免费使用、开源的类Unix操作系统。\n\ninode：存储文件元信息的区域\n\n文件目录树\n\n![image-20210408200944162](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408200944.png)\n\n\n\nShell编程：对一堆Linux命令的逻辑化处理\n\n","categories":["面试题"]},{"title":"Java","url":"/2021/04/09/Java/","content":"\n## 基础\n\n*什么是JVM、字节码、JDK、JRE？*\n\nJava 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。\n\n在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。\n\nJDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。\n\nJRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。\n\n\n\n*Java和C++的区别？*\n\n- 都是面向对象的语言，都支持封装、继承和多态\n- Java 不提供指针来直接访问内存，程序内存更加安全\n- Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。\n- Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存\n- **在 C 语言中，字符串或字符数组最后都会有一个额外的字符`'\\0'`来表示结束。但是，Java 语言中没有结束符这一概念。** \n\n\n\n*解释Java语言“编译于解释并存”*\n\nJava 语言既具有编译型语言的特征，也具有解释型语言的特征，因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（*.class 文件），这种字节码必须由 Java 解释器来解释执行。因此，我们可以认为 Java 语言编译与解释并存。\n\n\n\n*Java泛型和类型擦除？*\n\nJava泛型是JDK5引入的新特性，泛型本质是参数化类型，所操作的数据类型被指定为一个参数，Java的泛型是伪泛型，因为在编译期间，所有泛型信息都会被擦掉，这也就是通常所说类型擦除。\n\n泛型一般有三种使用方式：泛型类，泛型接口，泛型方法。\n\n\n\n*==和equals()的区别？*\n\n==用于判断两个对象的地址是否相等，即判断两个对象是不是同一个对象，基本类型比较值，引用类型比较内存地址。\n\nequals()用于判断两个对象是否相等，不能用于比较基本数据类型变量。equals是Object类（所有类的直接或 间接父类）中的方法。\n\n```java\npublic boolean equals(Object obj) {\n    return (this == obj);\n}\n```\n\n若没有被覆盖，等价于==；若被覆盖，都覆盖equals()方法比较两个对象内容是否相等。比如String中的equals就是被覆盖的。\n\n\n\n*hashCode()与equals()*\n\nhashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个 int 整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。hashCode()定义在 JDK 的 Object 类中，这就意味着 Java 中的任何类都包含有 hashCode() 函数。\n\nhashCode()在HashSet中的使用：\n\n当你把对象加入 HashSet 时，HashSet 会先计算对象的 hashcode 值来判断对象加入的位置，同时也会与其他已经加入的对象的 hashcode 值作比较，如果没有相符的 hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同 hashcode 值的对象，这时会调用 equals() 方法来检查 hashcode 相等的对象是否真的相同。如果两者相同，HashSet 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样就大大减少了equals次数。\n\n重写equals必须重写hashCode：\n\njava编程里有关约定：如果两个对象根据equals方法比较是相等的，那么调用这两个对象的任意一个hashcode方法都必须产生相同的结果。没有重写hashcode会导致违反这一条约定。\n\n\n\n*基本类型的包装类和常量池？*\n\nJava 基本类型的包装类的大部分都实现了常量池技术，即 Byte,Short,Integer,Long,Character,Boolean；前面 4 种包装类默认创建了数值[-128，127] 的相应类型的缓存数据，Character 创建了数值在[0,127]范围的缓存数据，Boolean 直接返回 True Or False。如果超出对应范围仍然会去创建新的对象。浮点类型的包装类没有实现常量池技术。\n\n\n\n*BigDecimal用处？*\n\n浮点数之间的等值判断，使用BigDecimal来定义浮点数的值，再进行浮点数的运算操作。大小比较用compareTo()，推荐使用BigDecimal(String)构造方法来构造对象而不是BigDecimal(double)。\n\n\n\n*Java方法参数使用（值传递）？*\n\n- 一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。\n- 一个方法可以改变一个对象参数的状态。\n- 一个方法不能让对象参数引用一个新的对象。\n\n\n\n*深拷贝和浅拷贝是什么？*\n\n浅拷贝对基本数据类型值传递，对引用数据类型引用传递；深拷贝对基本数据类型值传递，引用数据类型创建一个新对象并复制内容。\n\n\n\n*三大特征？*\n\n封装、继承、多态。\n\n\n\n*String StringBuffer StringBuilder?*\n\nString不可变（线程安全），StringBuffer和StringBuilder可变（都继承自AbstractStringBuilder类），StringBuffer对方法加了同步锁，线程安全，StringBuilder线程不安全。\n\n\n\n*Object类定义了哪些方法？*\n\n11个（Native方法是java调用非java代码的接口）\n\n```java\n\npublic final native Class<?> getClass()//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。\n\npublic native int hashCode() //native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。\n    \npublic boolean equals(Object obj)//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。\n\nprotected native Object clone() throws CloneNotSupportedException//native方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。\n\npublic String toString()//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。\n\npublic final native void notify()//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n\npublic final native void notifyAll()//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n\npublic final native void wait(long timeout) throws InterruptedException//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。\n\npublic final void wait(long timeout, int nanos) throws InterruptedException//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。\n\npublic final void wait() throws InterruptedException//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n\nprotected void finalize() throws Throwable { }//实例被垃圾回收器回收的时候触发的操作\n\n```\n\n\n\n*transient关键字？*\n\n用于阻止变量被序列化。\n\n\n\n*键盘输入方法？*\n\nScanner或BufferedReader。\n\n\n\n*什么是反射机制？*\n\nJAVA 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 java 语言的反射机制。常用于框架设计。\n\n1. 我们在使用 JDBC 连接数据库时使用 Class.forName()通过反射加载数据库的驱动程序；\n2. Spring 框架的 IOC（动态加载管理 Bean）创建对象以及 AOP（动态代理）功能都和反射有联系；\n\n\n\n*Java异常有哪些？*\n\n![image-20210406135014592](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210406135021.png)\n\n所有异常都继承自Throwable类，Exception能被程序本身用try-catch-finally处理，Error无法处理，Exception又分为受检异常（必须处理，不处理不能通过编译）和不受检异常（可以不处理，都是RuntimeException及其子类）\n\ntry-with-resources用于任何实现 java.lang.AutoCloseable或者 java.io.Closeable的对象，catch或finally块在资源关闭后运行。\n\n\n\n*java中的I/O流？*\n\n- 输入流和输出流\n- 字节流和字符流\n- 节点流和处理流\n\n\n\n*字节流和字符流？*\n\n虽然信息存储的最小单位都是字节，但Java虚拟机将字节转换成字符非常耗时，且容易出现乱码，所以提供了一个直接操作字符的接口，方便平时对字符进行流操作。\n\n\n\n*BIO,NIO,AIO?*\n\nBIO是同步阻塞IO模型，数据读写必须阻塞在一个线程内，模型简单，但处理不了连接量很高的情况。\n\nNIO是同步非阻塞IO模型，它支持面向缓冲的，基于通道的 I/O 操作方法。 NIO 提供了与传统 BIO 模型中的 `Socket` 和 `ServerSocket` 相对应的 `SocketChannel` 和 `ServerSocketChannel` 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。\n\nAIO（NIO2）是异步非阻塞IO模型，对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO 操作本身是同步的。异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。\n\n\n\n*Collection.toArray()方法？*\n\n```java\nString [] s= new String[]{\n    \"dog\", \"lazy\", \"a\", \"over\", \"jumps\", \"fox\", \"brown\", \"quick\", \"A\"\n};\nList<String> list = Arrays.asList(s);\nCollections.reverse(list);\ns=list.toArray(new String[0]);//没有指定类型的话会报错\n```\n\nnew String[0]起到了一个模板作用，指定类型同时节省空间。\n\n\n\n*枚举实现单例模式*\n\n```java\npublic enum PizzaDeliverySystemConfiguration {\n    INSTANCE;\n    PizzaDeliverySystemConfiguration() {\n        // Initialization configuration which involves\n        // overriding defaults like delivery strategy\n    }\n \n    private PizzaDeliveryStrategy deliveryStrategy = PizzaDeliveryStrategy.NORMAL;\n \n    public static PizzaDeliverySystemConfiguration getInstance() {\n        return INSTANCE;\n    }\n \n    public PizzaDeliveryStrategy getDeliveryStrategy() {\n        return deliveryStrategy;\n    }\n}\n```\n\n\n\n\n\n## 容器\n\n![image-20210406145500525](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210406145500.png)\n\n*List、Set、Map？*\n\nList：有序、可重复；Set：无序、不可重复；Map：键值对存储，无序、可重复。\n\n\n\n*ArrayList的扩容机制？*\n\n```java\n\npublic class ArrayList<E> extends AbstractList<E>\n        implements List<E>, RandomAccess, Cloneable, java.io.Serializable{\n\n  }\n```\n\n无参数创建ArrayList赋值给一个空数组，添加元素操作时才分配容量（大小为10）\n\n添加元素时使用 ensureCapacityInternal() 方法来保证容量足够，如果不够时，需要使用 grow() 方法进行扩容，新容量的大小为 `oldCapacity + (oldCapacity >> 1)`，即 oldCapacity+oldCapacity/2。其中 oldCapacity >> 1 需要取整，所以新容量大约是旧容量的 1.5 倍左右。（oldCapacity 为偶数就是 1.5 倍，为奇数就是 1.5 倍-0.5）\n\n扩容操作需要调用 `Arrays.copyOf()` 把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。\n\n\n\n*comparable和comparator*\n\n- `comparable` 接口实际上是出自`java.lang`包 它有一个 `compareTo(Object obj)`方法用来排序\n- `comparator`接口实际上是出自 java.util 包它有一个`compare(Object obj1, Object obj2)`方法用来排序\n\ncomparator定制排序（升序改成降序）\n\n```java\n Collections.sort(arrayList, new Comparator<Integer>() {\n\n            @Override\n            public int compare(Integer o1, Integer o2) {\n                return o2.compareTo(o1);\n            }\n        });\n```\n\n重写compareTo方法\n\n```java\n// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列\n// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了\npublic class Person implements Comparable<Person> {\n    private String name;\n    private int age;\n\n    public Person(String name, int age) {\n        super();\n        this.name = name;\n        this.age = age;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public void setAge(int age) {\n        this.age = age;\n    }\n\n    /**\n     * T重写compareTo方法实现按年龄来排序\n     */\n    @Override\n    public int compareTo(Person o) {\n        if (this.age > o.getAge()) {\n            return 1;\n        }\n        if (this.age < o.getAge()) {\n            return -1;\n        }\n        return 0;\n    }\n}\n```\n\n\n\n*HashSet,LinkedHashSet和TreeSet*\n\n`HashSet` 是 `Set` 接口的主要实现类 ，`HashSet` 的底层是 `HashMap`，线程不安全的，可以存储 null 值；\n\n`LinkedHashSet` 是 `HashSet` 的子类，能够按照添加的顺序遍历；\n\n`TreeSet` 底层使用红黑树，能够按照添加元素的顺序进行遍历，排序的方式有自然排序和定制排序。\n\n\n\n*HashMap的底层实现？*\n\nJDK1.8以前，数组和链表结合的链表散列，用扰动函数减少哈希碰撞，用拉链法解决冲突。\n\nJDK1.8 之后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。\n\n\n\n*Collections工具类*\n\n排序\n\n```java\nvoid reverse(List list)//反转\nvoid shuffle(List list)//随机排序\nvoid sort(List list)//按自然排序的升序排序\nvoid sort(List list, Comparator c)//定制排序，由Comparator控制排序逻辑\nvoid swap(List list, int i , int j)//交换两个索引位置的元素\nvoid rotate(List list, int distance)//旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面\n```\n\n查找替换\n\n```java\nint binarySearch(List list, Object key)//对List进行二分查找，返回索引，注意List必须是有序的\nint max(Collection coll)//根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)\nint max(Collection coll, Comparator c)//根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)\nvoid fill(List list, Object obj)//用指定的元素代替指定list中的所有元素。\nint frequency(Collection c, Object o)//统计元素出现次数\nint indexOfSubList(List list, List target)//统计target在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).\nboolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素\n```\n\n还提供了一些同步控制方法，但效率很低，需要线程安全的集合类型应该使用JUC包下的并发集合。\n\n\n\n## 并发\n\n*什么是线程和进程？*\n\n进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。\n\n在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。\n\n线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。\n\n与进程不同的是同类的多个线程共享进程的**堆**和**方法区**资源，但每个线程有自己的**程序计数器**、**虚拟机栈**和**本地方法栈**，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。\n\n一个Java程序的运行是main线程和多个其他线程同时运行。\n\n\n\n*程序计数器？*\n\n1. 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。\n2. 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。\n\n程序计数器私有主要是为了线程切换后能恢复到正确的执行位置。\n\n\n\n*虚拟机栈和本地方法栈？*\n\n虚拟机栈：每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。\n\n本地方法栈： 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。** 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。\n\n私有是为了线程中的局部变量不被别的线程访问到。\n\n\n\n*堆和方法区？*\n\n堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (几乎所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n\n\n*线程的生命周期和状态？*\n\n| 状态名称     | 说明                                                         |\n| ------------ | ------------------------------------------------------------ |\n| NEW          | 初始状态，线程被构建，但还没有调用start()方法                |\n| RUNNABLE     | 运行状态，Java线程将操作系统中的就绪和运行两种装填笼统地称作“运行中” |\n| BLOCKED      | 阻塞状态，表示线程阻塞于锁                                   |\n| WAITING      | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出一些特定动作(通知或中断) |\n| TIME_WAITING | 超时状态，该状态不同于WAITING，它是可以在指定的时间自行返回的 |\n| TERMINATED   | 终止状态，表示当前线程已经执行完毕                           |\n\n![image-20210408151705840](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408151713.png)\n\n\n\n*上下文切换？*\n\n多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。\n\n概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。\n\n\n\n*线程死锁？*\n\n四个条件\n\n- 互斥等待\n- 请求和保持\n- 不剥夺\n- 循环等待\n\n避免死锁：破坏四个条件之一\n\n\n\n*sleep()和wait()？*\n\n二者都可以暂停线程的执行，sleep()方法没有释放锁，wait()方法释放了锁，wait()一般用于线程交互/通信，调用后，线程需要别的线程调用notify()或notifyAll()方法；sleep()用于暂停执行，执行完毕后，线程会自动苏醒。\n\n\n\n*为什么不直接调用run()，而要调用start()？*\n\n调用start()方法可以启动线程并使线程进入就绪状态，直接执行run()方法不会以多线程方式执行，只会把它当作main线程下的一个普通方法执行。\n\n\n\n*synchronized关键字？*\n\n用于解决多个线程之间访问资源的同步性，可以保证它修饰的方法或者代码块在任意时刻只能有一个线程执行。以前效率很低下，现在引入优化效率很不错，应用广泛。\n\n\n\n*怎么使用synchronized关键字的？*\n\n主要有三种，一是修饰实例方法；二是修饰静态方法，也就是给当前类加锁；三是修饰代码块，如下：\n\n```java\nsynchronized(this) {\n  //业务代码\n}\n```\n\n双重校验锁实现对象单例（线程安全）：\n\n```java\npublic class Singleton {\n\n    private volatile static Singleton uniqueInstance;\n    // volatile可以禁止JVM指令重排\n\n    private Singleton() {\n    }\n\n    public  static Singleton getUniqueInstance() {\n       //先判断对象是否已经实例过，没有实例化过才进入加锁代码\n        if (uniqueInstance == null) {\n            //类对象加锁\n            synchronized (Singleton.class) {\n                if (uniqueInstance == null) {\n                    uniqueInstance = new Singleton();\n                }\n            }\n        }\n        return uniqueInstance;\n    }\n}\n\n```\n\n注意：构造方法本身就是线程安全的，不能使用synchronized关键字修饰\n\n\n\n*原理？*\n\n`synchronized` 同步语句块的实现使用的是 `monitorenter` 和 `monitorexit` 指令，其中 `monitorenter` 指令指向同步代码块的开始位置，`monitorexit` 指令则指明同步代码块的结束位置。\n\n`synchronized` 修饰的方法并没有 `monitorenter` 指令和 `monitorexit` 指令，取得代之的确实是 `ACC_SYNCHRONIZED` 标识，该标识指明了该方法是一个同步方法。\n\n本质都是对对象监视器monitor的获取。\n\n\n\n*优化（JDK1.6）？*\n\n1. 自旋锁：让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。\n\n   自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。\n\n2. 锁消除：对于被检测出不可能存在金正的共享数据的锁进行消除。锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。\n\n3. 锁粗化：如果一系列的连续操作都对同一个对象反复加锁和解锁，频繁的加锁操作就会导致性能损耗。如果虚拟机探测到由这样的一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。\n\n4. 轻量级锁\n\n5. 偏向锁\n\n\n\n*synchronized和ReentrantLock区别？*\n\n前者依赖于jvm后者依赖于api，后者增加了一些高级功能：\n\n1. 等待可中断\n2. 可实现公平锁\n3. 可实现选择性通知\n\n\n\n*volatile关键字？*\n\n在 JDK1.2 之前，Java 的内存模型实现总是从主存（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存本地内存（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。\n\n要解决这个问题，就需要把变量声明为volatile，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。\n\n所以，volatile关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。\n\n\n\n*并发编程的三个重要特性？*\n\n1. **原子性** : 一个的操作或者多次操作，要么所有的操作全部都得到执行并且不会收到任何因素的干扰而中断，要么所有的操作都执行，要么都不执行。`synchronized` 可以保证代码片段的原子性。\n2. **可见性** ：当一个变量对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。`volatile` 关键字可以保证共享变量的可见性。\n3. **有序性** ：代码在执行的过程中的先后顺序，Java 在编译器以及运行期间的优化，代码的执行顺序未必就是编写代码时候的顺序。`volatile` 关键字可以禁止指令进行重排序优化。\n\n\n\n*synchronized和volatile关键字的区别？*\n\n二者互补。\n\nvolatile关键字是线程同步的轻量级实现，所以volatile性能肯定比synchronized关键字要好。但是volatile关键字只能用于变量而 synchronized关键字可以修饰方法以及代码块。\nvolatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。\nvolatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。\n\n\n\n*ThreadLocal*\n\nThreadLocal用于修饰专属本地变量，如果创建一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本。他们可以使用 `get` 和 `set` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。\n\n每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。\n\n\n\n*线程池？*\n\n池化思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。\n\n**线程池**提供了一种限制和管理资源（包括执行一个任务）。 每个**线程池**还维护一些基本统计信息，例如已完成任务的数量。\n\n**使用线程池的好处**：\n\n- **降低资源消耗**。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。\n- **提高响应速度**。当任务到达时，任务可以不需要的等到线程创建就能立即执行。\n- **提高线程的可管理性**。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。\n\n\n\n*Runnable接口和Callable接口？*\n\n前者不会返回抛出检查异常，后者可以。Executors可以实现转换。\n\n\n\n*execute()和submit()？*\n\nexecute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；\nsubmit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个Future对象可以判断任务是否执行成功。\n\n\n\n*创建线程池?*\n\n推荐用ThreadPoolExecutor。\n\n\n\n*Atomic原子类？*\n\n有原子/原子操作特征的类，JUC的包都在原子类。有四种类型：\n\n1. 基本类型：使用原子方式更新基本类型\n2. 数组类型：使用原子方式更新数组元素\n3. 引用类型\n4. 对象修改属性类型\n\n\n\n*举例，比如AtomicInteger是怎么用的？*\n\n使用后不加锁也能保证线程安全。\n\n\n\n\n\n*AQS？*\n\nAQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器。\n\n主要组件有：信号量Semaphore，倒计时器CountDownLatch、循环栅栏CyclicBarrier。\n\n\n\n*CountDownLatch？*\n\n`CountDownLatch` 的作用就是 允许 count 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。之前在项目中，有一个使用多线程读取多个文件处理的场景，我用到了 `CountDownLatch` 。具体场景是下面这样的：\n\n我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。\n\n为此我们定义了一个线程池和 count 为 6 的`CountDownLatch`对象 。使用线程池处理读取任务，每一个线程处理完之后就将 count-1，调用`CountDownLatch`对象的 `await()`方法，直到所有文件读取完之后，才会接着执行后面的逻辑。\n\n\n\n## JVM\n\n*内存区域*\n\n**线程私有的：**\n\n- 程序计数器\n- 虚拟机栈\n- 本地方法栈\n\n**线程共享的：**\n\n- 堆\n- 方法区\n- 直接内存 (非运行时数据区的一部分)\n\n\n\n*对象创建过程？*\n\n1. 类加载检查\n\n2. 分配内存\n\n   1. 分配方式\n      1. 指针碰撞：没有内存碎片的情况下，用过的内存整合到一边，没用过的放另一边，中间有一个分界指针，只需要向没用过的内存方向将该指针移动对象内存大小位置即可。\n\n      2. 空闲列表：堆内存不规整情况下，维护一个列表，记录哪些可用，分配的时候找一个足够大的内存块给对象实例，最后更新表。\n   2. 内存分配并发\n      - **CAS+失败重试：** CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。**\n      - **TLAB：** 为每一个线程预先在 Eden 区分配一块内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配。\n\n3. 初始化零值\n4. 设置对象头\n5. 执行init方法\n\n\n\n**垃圾回收**\n\nJava 堆是垃圾收集器管理的主要区域，因此也被称作**GC 堆（Garbage Collected Heap）**.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。进一步划分的目的是更好地回收内存，或者更快地分配内存。\n\n![image-20210408211212836](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408211212.png)\n\n对象优先在eden区分配，大对象直接进入老年代，长期存活的对象进入老年代。\n\n\n\n*怎样垃圾回收？*\n\n两大种GC\n\n部分收集 (Partial GC)：\n\n- 新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；\n- 老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；\n- 混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。\n\n整堆收集 (Full GC)：收集整个 Java 堆和方法区。\n\n\n\n*判断对象是否死亡？*\n\n引用计数法：给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。简单，但很难解决循环引用问题。\n\n可达性分析算法：过一系列的称为 **“GC Roots”** 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。\n\n\n\n*引用？*\n\n1. 强引用：不回收、new创建\n2. 软引用：内存不够才会回收、使用 SoftReference 类来创建软引用。\n3. 弱引用：被弱引用关联的对象一定会被回收，也就是说它只能存活到下一次垃圾回收发生之前。使用 WeakReference 类来创建弱引用。\n4. 虚引用：又称为幽灵引用或者幻影引用，一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。使用 PhantomReference 来创建虚引用。\n\n\n\n*垃圾收集算法？*\n\n标记清除、标记复制、标记整理、分代收集。\n\n\n\n*垃圾收集器？*\n\n![image-20210408212105530](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408212105.png)\n\n- Serial收集器：以串行的方式执行。它是单线程的收集器，只会使用一个线程进行垃圾收集工作。\n\n- ParNew收集器：前者的多线程版本\n\n- Parallel Scavenge 收集器\n\n  与 ParNew 一样是多线程收集器。其它收集器目标是尽可能缩短垃圾收集时用户线程的停顿时间，而它的目标是达到一个可控制的吞吐量，因此它被称为“吞吐量优先”收集器。\n\n- Serial Old收集器：Serial的老年代版本\n\n- Parallel Old：是 Parallel Scavenge 收集器的老年代版本。\n\n- CMS（Concurrent Mark Sweep），Mark Sweep 指的是标记 - 清除算法。\n\n- G1（Garbage-First），它是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。HotSpot 开发团队赋予它的使命是未来可以替换掉 CMS 收集器。\n\n  堆被分为新生代和老年代，其它收集器进行收集的范围都是整个新生代或者老年代，而 G1 可以直接对新生代和老年代一起回收。\n\n\n\n*类加载过程？*\n\n1. 加载：\n   - 通过类的完全限定名称获取定义该类的二进制字节流。\n   - 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。\n   - 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。\n2. 验证：确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。\n3. 准备：准备阶段为类变量分配内存并设置初始值，使用的是方法区的内存。\n4. 解析：将常量池的符号引用替换为直接引用的过程。\n5. 初始化：初始化阶段才真正开始执行类中定义的 Java 程序代码。\n\n\n\n*类加载器？*\n\n类加载器之间的层次关系称为双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其它的类加载器都要有自己的父类加载器。这里的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。\n\n![image-20210408212636962](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408212637.png)\n\n使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。","categories":["面试题"]},{"title":"网络","url":"/2021/04/09/网络/","content":"\n*五层协议？*\n\n**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。应用层交互的数据单元称为报文。\n\n**运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。主要使用TCP（传输控制协议）和UDP（用户数据协议）。\n\n**在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。** 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。\n\n**数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。** 在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。\n\n**物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，** 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。\n\n最重要的就是TCP/IP协议，因此有时候用TCP/IP代指整个协议族。\n\n\n\n*TCP三次握手和四次挥手？*\n\n三次握手是为了准确无误地把数据送达目标处。\n\n![image-20210408161515387](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408161515.png)\n\nSYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n\n断开TCP连接需要使用“四次挥手”\n\n![image-20210408163040225](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408163040.png)\n\n任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。\n\n具体过程：\n\n三次握手\n\n![image-20210408163121462](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408163121.png)\n\n四次挥手\n\n![image-20210408163331761](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408163331.png)\n\nFIN=1表示连接释放报文，客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。\n\n客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：\n\n- 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。\n- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。\n\n\n\n*TCP和UDP有什么区别？*\n\n前者面向连接可靠，一般用于文件传输；后者无连接不可靠，一般用于即使通信，比如QQ视频等。\n\n\n\n*TCP如何保证可靠传输？*\n\n1. 应用数据被分割成 TCP 认为最适合发送的数据块。\n2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。\n3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。\n4. TCP 的接收端会丢弃重复的数据。\n5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）\n6. **拥塞控制：** 当网络拥塞时，减少数据的发送。\n7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。\n8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。\n\n\n\n*拥塞控制过程？*\n\n1. 慢开始：主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。\n2. 拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1。\n3.  在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。\n\n\n\n*在浏览器中输入url地址到显示主页的过程？*\n\n1. DNS解析：寻找哪台计算机上有你需要的资源，将网址转变为计算机的IP地址。优化：DNS缓存、DNS负载均衡（又叫DNS重定向，CDN技术就使用了）。\n2. TCP连接\n3. 发送HTTP请求\n4. 服务器处理请求并返回HTTP报文\n5. 浏览器解析渲染页面\n6. 连接结束\n\n\n\n*HTTP状态码*\n\n|      | 类别             | 原因短语                   |\n| ---- | ---------------- | -------------------------- |\n| 1XX  | 信息性状态码     | 接受的请求正在处理         |\n| 2XX  | 成功状态码       | 请求正常处理完毕           |\n| 3XX  | 重定向状态码     | 需要进行附加操作以完成请求 |\n| 4XX  | 客户端错误状态码 | 服务器无法处理请求         |\n| 5XX  | 服务器错误状态码 | 服务器处理请求出错         |\n\n\n\n*长连接，短连接？*\n\nHTTP/1.0默认使用短连接，也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。\n\n而从HTTP/1.1起，默认使用长连接，用以保持连接特性。\n\n\n\n*HTTP是无状态协议，如何保存用户状态？*\n\nSession机制，通过服务端记录用户状态。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。\n\n在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。\n\n\n\n*Cookie的作用是什么？和Session有什么区别？*\n\nCookie和Session都是用来跟踪浏览器用户身份的会话方式，但应用场景不一样。\n\nCookie一般用来保存用户信息，Session一般用来保存用户状态。Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。\n\n\n\n\n\n*HTTP1.0和HTTP1.1的主要区别？*\n\n1. 长连接和短连接\n2. HTTP1.1中新增了24个错误状态响应码\n3. :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。\n4. HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。\n\n\n\n*URI和URL的区别？*\n\n- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。\n- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。\n\nURI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\n\n\n\n*HTTP和HTTPS的区别？*\n\nHTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。\n\nHTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。\n\n- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；\n- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。","categories":["面试题"]},{"title":"数据库","url":"/2021/04/09/数据库/","content":"\n*mysql存储引擎 MyISAM和InnoDB的区别？*\n\nMyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。\n\n一般情况下都选用后者。\n\n\n\n*mysql索引？*\n\nMySQL索引使用的数据结构主要有**BTree索引** 和 **哈希索引** 。对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引。\n\nMySQL的BTree索引使用的是B树中的B+Tree，但对于主要的两种存储引擎的实现方式是不同的。\n\n\n\n*查询缓存的使用？*\n\n执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。\n\n\n\n*事务？*\n\n逻辑上的一组操作，要么都执行，要么都不执行。\n\n四大特性（ACID）\n\n1. **原子性（Atomicity）：** 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n2. **一致性（Consistency）：** 执行事务后，数据库从一个正确的状态变化到另一个正确的状态；\n3. **隔离性（Isolation）：** 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n4. **持久性（Durability）：** 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n\n\n\n*并发事务带来的问题？*\n\n脏读、丢失修改、不可重复读、幻影读。\n\n![image-20210408192348236](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408192348.png)\n\n![image-20210408192408423](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408192408.png)\n\n![image-20210408192500356](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408192500.png)\n\n![image-20210408192522582](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210408192522.png)\n\n\n\n*事务的隔离级别？*\n\n| 隔离级别                    | 脏读 | 不可重复读 | 幻影读 |\n| --------------------------- | ---- | ---------- | ------ |\n| READ-UNCOMMITTED 读取未提交 | √    | √          | √      |\n| READ-COMMITTED 读取已提交   | ×    | √          | √      |\n| REPEATABLE-READ 可重复读    | ×    | ×          | √      |\n| SERIALIZABLE 可串行化       | ×    | ×          | ×      |\n\nInnoDB默认的是可重复读，与 SQL 标准不同的地方在于 InnoDB 存储引擎在 **REPEATABLE-READ（可重读）** 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生。\n\n\n\n*锁机制？*\n\n- MyISAM采用表级锁(table-level locking)。\n- InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁。\n\n表级锁对整张表上锁，实现简单，资源消耗少，不会死锁，但并发度低。\n\n行级锁只对当前进行操作的行上锁，能大大减少数据库操作的冲突，并发度高。\n\n**InnoDB存储引擎的锁的算法有三种：**\n\n- Record lock：单个行记录上的锁\n- Gap lock：间隙锁，锁定一个范围，不包括记录本身\n- Next-key lock：record+gap 锁定一个范围，包含记录本身\n\n\n\n*大表优化？*\n\n限定数据范围、读写分离、垂直分区、水平分区。\n\n\n\n*数据库连接池？*\n\n池化思想就是每次预设初始资源，减少每次获取资源的消耗。\n\n数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中**。 连接池还减少了用户必须等待建立与数据库的连接的时间。\n\n\n\n*分库分表后，id主键如何处理？*\n\n- **UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。\n- **数据库自增 id** : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。\n- **利用 redis 生成 id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。\n- **Twitter的snowflake算法** \n- **美团的[Leaf](https://tech.meituan.com/2017/04/21/mt-leaf.html)分布式ID生成系统** ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。\n\n\n\n\n\n*介绍Redis?*\n\nRedis是一个使用C语言开发的数据库，不过于传统数据库不同的是Redis数据是存在内存中的，所以读写非常快，因此Redis被广泛应用于缓存方向。\n\n\n\n*分布式缓存，Redis和Memecache？*\n\n1. Redis 支持更丰富的数据类型（支持更复杂的应用场景）。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。\n2. Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memecache 把数据全部存在内存之中。\n3. Redis 有灾难恢复机制。因为可以把缓存中的数据持久化到磁盘上。\n4. Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。\n5. Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。\n6. Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。（Redis 6.0 引入了多线程 IO ）\n7. Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。\n8. Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。\n\n\n\n*缓存的处理流程？*\n\n1. 如果用户请求的数据在缓存中就直接返回。\n2. 缓存中不存在的话就看数据库中是否存在。\n3. 数据库中存在的话就更新缓存中的数据。\n4. 数据库中不存在的话就返回空数据。\n\n\n\n*为什么用Redis？*\n\n高性能角度：\n\n假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。\n\n**这样有什么好处呢？** 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。\n\n不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！\n\n高并发：\n\n一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。\n\n所以，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高的系统整体的并发。\n\n\n\n*Redis过期机制？*\n\n缓解内存消耗，Redis使用过期字典来保存。\n\n\n\n*Redis持久化机制？*\n\n快照持久化（默认）：\n\nRedis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。\n\nAOF（append-only file）机制\n\nAOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。\n\n\n\n注意：Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。但不满足原子性。\n\n\n\n*缓存穿透？*\n\n大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。\n\n解决方法：\n\n参数校验，不合法的参数请求直接抛出异常。\n\n布隆过滤器：布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法。\n\n具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。\n\n但可能会误判，因为可能有哈希碰撞。\n\n\n\n*缓存雪崩？*\n\n实际上，缓存雪崩描述的就是这样一个简单的场景：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。系统的缓存模块出了问题比如宕机导致不可用。造成系统的所有访问，都要走数据库。\n\n还有一种缓存雪崩的场景是：有一些被大量访问数据（热点缓存）在某一时刻大面积失效，导致对应的请求直接落到了数据库上。\n\n- 针对 Redis 服务不可用的情况：\n\n1. 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。\n2. 限流，避免同时处理大量的请求。\n\n- 针对热点缓存失效的情况：\n\n1. 设置不同的失效时间比如随机设置缓存的失效时间。\n2. 缓存永不失效。\n\n\n\n*缓存和数据库数据的一致性？*\n\n旁路缓存模式，遇到写请求更新 DB，然后直接删除 cache 。","categories":["面试题"]},{"title":"剑指offer","url":"/2021/04/07/剑指offer/","content":"\n### 03 数组中的重复数字\n\n关键：数字范围是 0 ~  n - 1\n\n把每个数字都移到对应的索引位置（如果不在），如果有重复就可以发现。也可以用哈希表记录出现次数。\n\n\n\n### 04 二维数组中的数字\n关键：数字递增\n\n判断和目标的大小关系，一次排除一行或一列。\n\n\n\n### 05 替换空格\n\n用一个新的StringBuffer按规则插入即可。\n\n\n\n### 06 从尾到头打印链表\n\n利用栈先进后出的性质存储节点值即可。\n\n\n\n### 07 重建二叉树\n\n前序确定根节点，找到在中序中的位置，确定左右子树大小，递归建树。\n\n```java\nclass Solution {\n    private Map<Integer, Integer> indexOfOrder = new HashMap<>();\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        // 这一步省略了之后传inorder参数，同时方便找根节点在中序中的位置\n        for (int i = 0; i < inorder.length; i++) {\n            indexOfOrder.put(inorder[i], i);\n        }\n        return buildTree(preorder,0, preorder.length - 1,0);\n    }\n\t\n    // prel~prer表示要构建的树对应的前序范围，inl是正在构建的树中序遍历的第一个元素\n    public TreeNode buildTree(int[] preorder, int prel, int prer, int inl) {\n        if (prel > prer) return null;\n        TreeNode root = new TreeNode(preorder[prel]);\n        int index = indexOfOrder.get(root.val);\n        int leftsize = index - inl;\n        root.left = buildTree(preorder, prel + 1, prel + leftsize, inl);\n        root.right = buildTree(preorder, prel + leftsize + 1, prer, inl + leftsize + 1);\n        return root;\n    }\n}\n```\n\n\n\n### 09 用两个栈实现队列\n\n一个用来进，一个用来出。\n\n\n\n### 10-1 斐波那契数列\n\n只需保存之前的前两个值，时间和空间复杂度最小。\n\n\n\n### 10-2 青蛙跳台阶问题\n\n和斐波那契数列一样，f(n) = f(n-1) + f(n-2)，注意其中的动态规划思想，更复杂的场景也能应用。\n\n\n\n### 11 旋转数组的最小数字\n\n用二分查找时间最少，关键是判断分开的两个数组中哪一个包含被旋转的子数组。\n\n\n\n### 12 矩阵中的路径\n\n回溯法\n\n```java\nclass Solution {\n    \t// 记录四个不同的方向\n        private final int[][] next = {{1,0},{0,1},{-1,0},{0,-1}};\n        private int rows,cols;\n\n        public boolean exist(char[][] board, String word) {\n            this.rows = board.length;\n            this.cols = board[0].length;\n            // 标记该位置是否走过\n            boolean[][] marked = new boolean[rows][cols];\n            char[] path = word.toCharArray();\n            for (int i = 0; i < rows; i++) {\n                for (int j = 0; j < cols; j++) {\n                    // 从任意位置开始，能否找到路径\n                    if ( backtracking(board, path, marked, 0, i, j)) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        }\n\t\t\n    \t// 走到了i,j位置，是否找到了该路径\n        private boolean backtracking(char[][] board, char[] path, boolean[][] marked,int pathlen, int i, int j) {\n            // 找到了路径\n            if (pathlen == path.length) return true;\n            \n            // 经过i,j位置不可能找到路径，返回\n            if ( i < 0 || i >= rows || j < 0 || j >= cols || marked[i][j] ||\n            board[i][j] != path[pathlen] )\n                return false;\n\t\t\t\n            // 该位置有可能找到路径，先标记该位置已走过\n            marked[i][j] = true;\n\t\t\t\n            // 向每个方向找路径\n            for (int[] dir : next) {\n                if (backtracking(board, path, marked, pathlen + 1, i + dir[0], j + dir[1]))\n                    return true;\n            }\n\t\t\t\n            // 没有找到，此路不通，去除标记\n            marked[i][j] = false;\n\n            return false;\n        }\n}\n```\n\n\n\n### 13 机器人的运动路径\n\n```java\nclass Solution {\n    \t// 记录四个不同的方向\n        private final int next[][] = {{0,1},{1,0},{0,-1},{-1,0}};\n    \t// 记录能走多少个格子\n        private int count = 0;\n\n\n        public int movingCount(int m, int n, int k) {\n            // 标记该位置是否判断过\n            boolean[][] marked = new boolean[m][n];\n            backtracking( m, n, k, marked, 0, 0);\n            return count;\n\n        }\n\n        private void backtracking(int m, int n, int k, boolean[][] marked, int i, int j) {\t\t\t // 不是一个矩阵或者该位置已经判断过，直接返回\n            if ( i < 0 || i >= m || j < 0 || j >= n || marked[i][j]) return;\n\t\t\t\n            // 该位置已判断\n            marked[i][j] = true;\n\t\t\t\n            // 不能走，返回\n            if ( sum(i, j) > k ) return;\n\t\t\t\n            // 能走，能走的格子数+1\n            count++;\n\t\t\t\n            // 向四个方向再找能走的格子\n            for (int[] dir : next) {\n                backtracking(m, n, k, marked, i + dir[0], j + dir[1]);\n            }\n        }\n\n        private int sum(int i, int j) {\n            return (i/10 + i%10) + (j/10 + j%10);\n        }\n}\n```\n\n\n\n### 14-1 剪绳子I\n\n动态规划法\n\n```java\npublic int cuttingRope(int n) {\n    \t// dp[n]表示n段绳子最大乘积\n        int[] dp = new int[n+1];\n    \t// 初始化\n        dp[2] = 1;\n        for (int i = 3; i <= n; i ++)\n            for (int j = 2; j < i; j++) // 至少剪长度为2\n                // 状态转移方程\n                dp[i] = Math.max(dp[i], Math.max(j * (i -j), j * dp[i - j]));\n\n        return dp[n];\n}\n```\n\n\n\n### 14-2 剪绳子II\n\n找规律，剪长度为3最大，最后的剪成2*2\n\n\n\n### 15 二进制中1的个数\n\n位运算，n & (n - 1)，每次可以消除一个1，直到n变成0\n\n\n\n### 16 数组的整数次方\n\n递归实现，注意考虑正负\n\n\n\n### 17 打印从1到最大的n位数\n\n略\n\n\n\n### 18 删除链表的结点\n\n两个指针一前一后跑\n\n\n\n### 19 正则表达式的匹配\n\n复杂问题考虑动态规划\n\n```java\npublic boolean isMatch(String s, String p) {\n        int m = s.length(); // m表示要检测字符串的长度\n        int n = p.length(); // n表示模式的长度\n        boolean[][] dp = new boolean[m + 1][n + 1]; // dp[i][j]表示s的前i项和p的前j项是否匹配\n        dp[0][0] = true;// 初始化，两个空串肯定匹配\n    \t// 有*的位置，前一个字符可以任意匹配，所以这两个字符不影响结果\n        for (int i = 1; i <= n; i++) {\n            if (p.charAt(i - 1) == '*')\n                dp[0][i] = dp[0][i - 2];\n        }\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n               // .可以匹配任意一个字符\n                if ( s.charAt(i - 1) == p.charAt(j - 1) || p.charAt(j - 1) == '.')\n                    dp[i][j] = dp[i - 1][j - 1];\n                // 遇到*\n                else if (p.charAt(j - 1) == '*') {\n                     if (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.') {\n                         dp[i][j] |= dp[i][j - 1]; // *可以当单个字符\n                         dp[i][j] |= dp[i - 1][j]; // *可以当多个字符\n                         dp[i][j] |= dp[i][j - 2]; // *可以当空字符\n                     }\n                     else\n                         dp[i][j] = dp[i][j - 2]; \n                }\n\n            }\n        }\n        return dp[m][n];\n    }\n```\n\n\n\n### 21 表示数值的字符串\n\n用正则表达式匹配\n\n\n\n### 22 调整数组顺序使得奇数位于偶数前面\n\n建一个新数组来存\n\n\n\n### 23 链表中倒数第k个结点\n\n关键：不知道链表中有多少个结点，无法确定第k个位置\n\n用双指针，一个比另一个多跑k次，第一个到达终点，第二个在倒数第k个位置\n\n\n\n### 24 反转链表\n\n用头插法，注意要使用一个辅助节点\n\n\n\n### 25 合并两个排序链表\n\n用递归的思想，确定每一步要把哪两个子链表合并到哪一个节点后面\n\n\n\n### 26 树的子结构\n\n递归判断\n\n```java\n// 判断B是不是A的子结构 \npublic boolean isSubStructure(TreeNode A, TreeNode B) {\n        if ( A == null || B == null )\n            return false;\n        return isSubTree(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B);\n    }\n// 判断B是不是A的子树\npublic boolean isSubTree(TreeNode A, TreeNode B) {\n    if ( B == null )\n        return true;\n    if ( A == null )\n        return false;\n    if ( A.val != B.val)\n        return false;\n    return isSubTree(A.left, B.left) && isSubTree(A.right, B.right);\n}\n```\n\n\n\n### 27 二叉树的镜像\n\n递归，交换子树再交换子树的子树，直到没有能交换的\n\n\n\n### 28 对称的二叉树\n\n递归判断\n\n```java\n// 判断以root为根的树是否对成\npublic boolean isSymmetric(TreeNode root) {\n        if (root == null)\n            return true;\n        return isSymmetric(root.left, root.right);\n}\n// 判断left和rigth是否对称\nprivate boolean isSymmetric(TreeNode left, TreeNode right) {\n    if (left == null && right == null)\n        return true;\n    if (left == null || right == null)\n        return false;\n    if (left.val != right.val)\n        return false;\n    // 左子树的左子树和右子树的右子树，以及左子树的右子树和右子树的左子树是否对称\n    return isSymmetric(left.left, right.right) && isSymmetric(left.right, right.left);\n}\n```\n\n\n\n### 29 顺时针打印矩阵\n\n按顺序输出即可，注意矩阵范围的变化\n\n\n\n### 31 栈的压入弹出序列\n\n用一个栈模拟弹出过程，看是否可行\n\n\n\n### 32-1 从上到下打印二叉树\n\n用队列存，一层一层打印\n\n\n\n### 32-2 从上到下打印二叉树II\n\n略\n\n\n\n### 32-3 从上到下打印二叉树III\n\n注意可以使用Collection.reverse()\n\n\n\n### 33 二叉搜索树的后序遍历序列\n\n```java\n public boolean verifyPostorder(int[] postorder) {\n        if (postorder == null || postorder.length == 0)\n            return true;\n        return verify(postorder, 0, postorder.length - 1);\n\n }\n\nprivate boolean verify(int[] postorder, int start, int end) {\n    if (end - start <= 1)\n        return true;\n    // 后序遍历最后一个元素是根节点\n    int rootval = postorder[end];\n    int cutindex = start;\n    // 找到第一个大于根节点的节点，即左右子树的分解\n    while (cutindex < end && postorder[cutindex] <= rootval) {\n        cutindex++;\n    }\n    // 检查右子树是否都大于根节点\n    for (int i = cutindex; i < end; i++) {\n        if (postorder[i] < rootval)\n            return false;\n    }\n    // 递归判断左右子树是否也是二叉搜索树的后序遍历序列\n    return verify(postorder, start, cutindex - 1) && verify(postorder, cutindex, end - 1);\n}\n```\n\n\n\n### 35 复杂链表的复制\n\n第一步，在每个节点后面插入复制节点；\n\n第二步，给复制节点的random赋值；\n\n第三步，拆分。\n\n为什么不能直接复制：链表不能随机访问，直接复制想找到random节点的位置，只能顺序查找，复杂度高。\n\n\n\n### 36 二叉搜索树和双向链表\n\n双指针+中序遍历构建\n\n\n\n### 37 序列化二叉树\n\n难点在于反序列化\n\n```java\nprivate TreeNode deserialize() {\n    if (deserializeStr.length() == 0)\n        return null;\n    // 找根节点\n    int index = deserializeStr.indexOf(\" \");\n    // 根节点的值\n    String node = index == -1 ? deserializeStr : deserializeStr.substring(0, index);\n    // 剩下需要反序列化的字符串\n    deserializeStr = index == -1 ? \"\" : deserializeStr.substring(index + 1);\n    if (node.equals(\"#\"))\n        return null;\n    int val = Integer.valueOf(node);\n    // 构建二叉树\n    TreeNode t = new TreeNode(val);\n    t.left = deserialize();\n    t.right = deserialize();\n    return t;\n}\n```\n\n\n\n\n\n### 38 字符串的排列\n\n搜索\n\n```java\nprivate ArrayList<String> res = new ArrayList<>();\n\npublic String[] permutation(String s) {\n    if ( s.length() == 0)\n        return res.toArray(new String[0]);\n    char[] chars = s.toCharArray();\n    Arrays.sort(chars);\n    backtracking(chars, new boolean[chars.length], new StringBuilder());\n    return res.toArray(new String[0]);\n\n}\n\nprivate void backtracking(char[] chars, boolean[] hasused, StringBuilder s) {\n    // 字符串已经用完，存入结果\n    if (s.length() == chars.length) {\n        res.add(s.toString());\n        return;\n    }\n\n    for (int i = 0; i < chars.length; i++) {\n        // 查找字符数组，已经用过跳到下一轮\n        if (hasused[i]) {\n            continue;\n        }\n        // 保证不重复\n        if (i != 0 && chars[i] == chars[i - 1] && !hasused[i - 1]) {\n            continue;\n        }\n        // 标记用过\n        hasused[i] = true;\n        s.append(chars[i]);\n        backtracking(chars, hasused, s);\n        s.deleteCharAt(s.length() - 1);\n        hasused[i] = false;\n    }\n\n}\n```\n\n\n\n\n\n### 39 数组中出现超过一半的数字\n\n利用出现超过一半的数字满足的特点，和其他数字两两相消最后会剩下\n\n\n\n### 40 最小的k个数字\n\n用一个最大堆，每次超过k个就把最大的poll，最后留下的就是最小的k个数字\n\n\n\n### 41 数据流中的中位数\n\n用一个大顶堆一个小顶堆，一左一右，中位数就是堆顶值的平均（注意奇偶的处理）\n\n\n\n### 42 连续子数组的最大和\n\n用动态规划\n\n\n\n### 43 1~n整数中1出现的次数\n\n用数学思想\n\n\n\n### 44 数字序列中某一位的数字\n\n同样用数学思想\n\n\n\n### 45 把数组排成最小的数\n\n定义新的比较方法`Arrays.sort(res, (s1, s2) -> (s1 + s2).compareTo(s2 + s1));`，从而得出最小排列\n\n\n\n### 46 把数字翻译成字符串\n\n动态规划\n\n\n\n### 47 礼物的最大价值\n\n```java\npublic int maxValue(int[][] values) {\n    if (values == null || values.length == 0 || values[0].length == 0)\n        return 0;\n    int n = values[0].length;\n    // dp[n]表示走n步能拿到的最大价值，最多能走n-1步\n    int[] dp = new int[n];\n    for (int[] value : values) {\n        dp[0] += value[0];\n        for (int i = 1; i < n; i++)\n            dp[i] = Math.max(dp[i], dp[i - 1]) + value[i];\n    }\n    return dp[n - 1];\n}\n```\n\n\n\n\n\n### 48 最长不含重复字符的子字符串\n\n用哈希表\n\n```java\npublic int lengthOfLongestSubstring(String s) {\n    Map<Character, Integer> dic = new HashMap<>();\n    int res = 0, tmp = 0;\n    for(int j = 0; j < s.length(); j++) {\n        int i = dic.getOrDefault(s.charAt(j), -1); // 获取索引 i\n        dic.put(s.charAt(j), j); // 更新哈希表\n        tmp = tmp < j - i ? tmp + 1 : j - i; // dp[j - 1] -> dp[j]\n        res = Math.max(res, tmp); // max(dp[j - 1], dp[j])\n    }\n    return res;\n}\n```\n\n\n\n### 49 丑数\n\n```java\npublic int nthUglyNumber(int N) {\n    if (N <= 6)\n        return N;\n    int i2 = 0, i3 = 0, i5 = 0;\n    // dp[i-1]表示第i个丑数\n    int[] dp = new int[N];\n    dp[0] = 1;\n    for (int i = 1; i < N; i++) {\n        int next2 = dp[i2] * 2, next3 = dp[i3] * 3, next5 = dp[i5] * 5;\n        dp[i] = Math.min(next2, Math.min(next3, next5));\n        if (dp[i] == next2)\n            i2++;\n        if (dp[i] == next3)\n            i3++;\n        if (dp[i] == next5)\n            i5++;\n    }\n    return dp[N - 1];\n}\n```\n\n\n\n\n\n### 50 第一个只出现一次的字符\n\n用哈希表存储字符的出现次数\n\n\n\n### 51 数组中的逆序对\n\n利用归并排序\n\n\n\n### 52 两个链表的第一个公共节点\n\n两个指针分别先后在两个链表上走，第一次相遇在公共节点\n\n\n\n### 53-I 在排序数组中查找数字I\n\n顺序查找即可\n\n\n\n### 53-II 0~n-1中缺失的数字\n\n二分查找，先根据中值判断这个数字在哪边，然后根据和前一个数的距离判断这个数字在哪\n\n\n\n### 54 二叉搜索树的第k大节点\n\n中序遍历存到数组里面\n\n\n\n### 55-I 二叉树的深度\n\n递归，深度等于两个字数深度比较大的+1\n\n\n\n### 55-II 平衡二叉树\n\n利用深度函数，同样递归判断\n\n\n\n### 56-I 数组中数字出现的次数\n\n用哈希表即可\n\n\n\n### 56-II 数组中数字出现的次数II\n\n同上\n\n\n\n### 57 和为s的两个数字\n\n利用排序性质，双指针解决\n\n\n\n### 57-II 和为s的连续正数序列\n\n用双指针标记序列范围，注意指针变化情况\n\n\n\n### 58-I 翻转单词顺序\n\n先翻转每个单词，再翻转整个字符串\n\n\n\n### 58-II 左旋转字符串\n\n先翻转整个字符串，再分别翻转左右字符串\n\n\n\n### 59 队列的最大值\n\n借助双端队列实现\n\n\n\n### 60 n个骰子的点数 \n\n```java\npublic double[] dicesProbability(int n) {\n    double[] dp = new double[6];\n    Arrays.fill(dp, 1.0 / 6.0);\n    for (int i = 2; i <= n; i++) {\n        double[] tmp = new double[5 * i + 1];\n        for (int j = 0; j < dp.length; j++) {\n            for (int k = 0; k < 6; k++) {\n                tmp[j + k] += dp[j] / 6.0;\n            }\n        }\n        dp = tmp;\n    }\n    return dp;\n}\n```\n\n\n\n\n\n### 61 扑克牌中的顺子\n\n记录下0的数量，判断顺子的时候使用0，如果0不够则不是顺子\n\n\n\n### 62 圆圈中最后剩下的数字\n\n可以按正常思路求解，也可以利用少一个人后的情况递归求解\n\n\n\n### 63 股票的利润\n\n最大子数组问题的变化\n\n\n\n### 64 求1+2+...+n\n\n```java\npublic int sumNums(int n) {\n    int sum = n;\n    boolean b = (n > 0) && ((sum += sumNums(n - 1)) > 0);\n    return sum;\n}\n```\n\n\n\n### 65 不用加减乘除做加法\n\n递归+移位 \n\n```java\npublic int add(int a, int b) {\n    return b == 0 ? a : add(a^b, (a & b) << 1);\n}\n```\n\n\n\n### 66 构建乘积数组\n\n从两边分别累乘\n\n\n\n### 67 把字符串转换成整数\n\n根据题目要求逐步求解即可\n\n```java\npublic int strToInt(String str) {\n    int res = 0, bndry = Integer.MAX_VALUE / 10;\n    int i = 0, sign = 1, length = str.length();\n    if(length == 0) return 0;\n    while(str.charAt(i) == ' ')\n        if(++i == length) return 0;\n    if(str.charAt(i) == '-') sign = -1;\n    if(str.charAt(i) == '-' || str.charAt(i) == '+') i++;\n    for(int j = i; j < length; j++) {\n        if(str.charAt(j) < '0' || str.charAt(j) > '9') break;\n        if(res > bndry || res == bndry && str.charAt(j) > '7')\n            return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n        res = res * 10 + (str.charAt(j) - '0');\n    }\n    return sign * res;\n}\n```\n\n\n\n### 68-I 二叉搜索树的最近公共祖先\n\n递归查找，如果找到和二者之一相等的则是该节点，否则是上一层的根节点\n\n\n\n### 68-II 二叉树的最近公共祖先\n\n同上\n\n\n\n\n\n\n\n","categories":["面试题"]},{"title":"软件工程 第8章 面向对象建模","url":"/2021/04/03/软件工程-第8章-面向对象建模/","content":"\n## 用况建模\n\n用况建模时用于描述一个系统应该做什么的建模技术。\n\n**用况建模步骤**\n\n1. 定义系统\n2. 确定执行者\n3. 确定用况\n4. 描述用况\n5. 确定用况间的关系\n6. 确认模型\n\n\n\n## 静态建模\n\n静态建模描述系统中包含的类以及类之间的关系，展示了软件系统的静态结构。\n\n*CRC技术*\n\n类-责任-协作者技术，一组表示类的索引卡片，每张卡片分成三个部分，分别描述类、类的责任和类的协作者\n\n\n\n*类之间的关系*\n\n| 关系 | 功能                                                         | 符号                     |\n| ---- | ------------------------------------------------------------ | ------------------------ |\n| 关联 | 类实例间连接的描述                                           | ——                       |\n| 依赖 | 二个模型元素之间的一种关系                                   | ----->                   |\n| 泛化 | 更特殊描述与更一般描述之间的一种关系，用于继承和多态性类型声明 | ——$\\vartriangleright$    |\n| 实现 | 规约（specification）与它的实现之间的关系                    | ------$\\vartriangleright$ |\n\n\n\n## 动态建模\n\n动态建模用来描述系统的动态行为，显示对象在运行期间不同时刻的动态交互。UML中用状态机图、活动图、顺序图、通信图和协作图来建立动态模型。\n\n*状态机图*\n\n画状态机图的步骤：\n\n1. 列出对象具有的所有状态\n2. 标识导致状态转换的事件\n3. 为状态和迁移定义状态变量和动作\n\n\n\n*活动图*\n\n\n\n*顺序图*\n\n\n\n*通信图*\n\n\n\n*协作图*\n\n\n\n## 物理体系结构建模\n\n系统的体系结构用来描述系统各部分的结构、接口以及它们用于通信的机制。\n\n物理体系结构涉及系统的详细描述（根据系统所包含的硬件和软件），显示了硬件的结构，包括不同的结点以及这些结点之间如何连接，还表示了代码模块的物理结构和依赖关系，并展示了对进程、程序、构建等软件在运行时的物理分配。\n\n\n\n*回答的问题*\n\n1. 类和对象物理上位于哪个程序或进程？\n2. 程序和进程在哪台计算机上执行？\n3. 系统中有哪些计算机和其他硬件设备？它们如何相互连接？\n4. 不同的代码文件之间有什么依赖关系？如果一个指定文件被改变，那么那些其他文件需要重新编译？\n\nUML使用中物理体系结构用构件图、内部结构图和部署图来描述\n\n\n\n*构件图*：显示构件类型定义、内部结构和依赖。\n\n\n\n*部署图*：部署图展示了运行时处理结点和在结点上生存的制品的配置。","categories":["软件工程"]},{"title":"软件工程 第2章 系统工程","url":"/2021/04/01/软件工程-第2章-系统工程/","content":"\n## 基于计算机的系统\n\n软件、硬件、人员、数据库、文档、规程\n\n\n\n## 系统工程的任务\n\n1. 识别用户的要求\n2. 系统建模和模拟\n   - 硬件系统模型\n   - 软件系统模型\n   - 人机接口模型\n   - 数据模型\n3. 成本估算及进度安排\n4. 可行性分析\n5. 生成系统规格说明\n\n\n\n## 可行性分析\n\n**经济可行性**\n\n经济可行性主要进行成本效益分析，从经济角度，确定系统是否值得开发。\n\n\n\n**技术可行性**\n\n技术可行性主要根据系统的功能、性能、约束条件等，分析在现有资源和技术条件下系统能否实现。包括风险分析、资源分析和技术分析。\n\n\n\n**法律可行性**\n\n\n\n\n\n","categories":["软件工程"]},{"title":"软件工程 第4章 设计工程","url":"/2021/04/01/软件工程-第4章-设计工程/","content":"\n## 软件设计工程概述\n\n软件设计时是把软件需求变成软件表示的过程\n\n\n\n**任务**\n\n1. 数据/类设计\n2. 体系结构设计\n3. 接口设计\n4. 部件级设计\n\n\n\n**目标**\n\n\n\n**过程**\n\n1. 制定规范\n2. 体系结构和接口设计\n3. 数据/类设计\n4. 部件级（过程）设计\n5. 编写设计文档\n6. 设计评审\n\n\n\n## 软件设计原则\n\n- 抽象与逐步求精\n- 模块化\n- 信息隐藏\n- 功能独立\n  - 内聚：一个模块内部各个元素彼此结合的紧密程度的度量\n  - 耦合：模块之间的相对独立性的度量\n\n\n\n## 软件体系结构设计\n\n**软件体系结构的风格**\n\n1. 以数据为中心的体系结构\n2. 数据流风格的体系结构\n3. 调用和返回风格的体系结构\n4. 面向对象风格的体系结构\n5. 层次式风格的体系结构\n\n\n\n## 部件级设计技术\n\n结构化程序设计\n\n\n\n**图形表示法**\n\n- 程序流程图\n- N-S图\n- PAD\n\n\n\n**判定表**\n\n\n\n**设计语言PDL**\n\n一种用于描述功能部件的算法设计和处理细节的语言，是一种伪代码\n\n\n\n## 设计规约与设计评审\n\n软件设计阶段的主要输出是设计规约，为了确保文档的质量，还必须对设计文档进行评审","categories":["软件工程"]},{"title":"软件工程 第5章 结构化分析与设计","url":"/2021/04/01/软件工程-第5章-结构化分析与设计/","content":"\n## 结构化分析方法的概述\n\n1. 抽象（自底向上）和分解（自顶向下）\n\n2. 结构化分析的过程\n\n   1. 理解当前的现实环境，获得当前系统的具体模型\n   2. 从当前系统的具体模型抽象出当前系统的逻辑模型\n   3. 分析目标系统与当前系统逻辑上的差别，建立目标系统的逻辑模型\n   4. 为目标系统的逻辑模型作补充\n\n3. 结构化分析模型的描述形式\n\n   ![image-20210401160457326](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210401160457.png)\n\n\n\n## 数据流图（DFD）\n\n描述输入数据流到输出数据流的变换（即加工），用于对系统的功能建模\n\n**数据流图的图形表示**\n\n1. 基本图形元素\n\n![image-20210401161352705](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210401161352.png)\n\n例：图书馆订购系统的DFD\n\n![image-20210401161621374](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210401161621.png)\n\n2. 扩充符号\n\n   1. 星号 * ：表示数据流之间存在”与“关系\n   2. 加号 + ：表示数据流之间存在”或“关系\n   3. 异或 $\\bigoplus$：表示数据流之间存在”异或“（互斥）关系\n\n3. 层次结构\n\n   每张图的加工数控制在 7$\\pm$2\n\n\n\n**分层数据流的画法**\n\n1. 画出系统的输入和输出\n2. 画出系统内部\n3. 画出加工内部\n4. 重复第三步，直至每个尚未分解的加工都足够简单\n\n\n\n## 分层数据流图的审查\n\n**一致性和完整性**\n\n*一致性*\n\n1. 父图与子图平衡\n2. 数据守恒\n3. 局部文件\n4. 一个加工的输出数据流不能与该加工的输入数据流同名\n\n*完整性*\n\n1. 每个加工至少有一个输入数据流和一个输出数据流\n2. 在整套分层数据流图中，每个文件至少有一个加工该读文件，有另一个加工写该文件\n3. 分层数据流图中的每个数据流和文件都必须命名（除了流入或流出文件的数据流），并保持与数据字典一致\n\n4. 分层DFD中的每个基本加工都应该有一个加工规约\n\n\n\n**构造分层DFD时需要注意的问题**\n\n1. 适当命名\n2. 画数据流而不是画控制流\n3. 避免一个加工有过多的数据流\n4. 分解尽可能均匀\n5. 先考虑稳定状态，忽略琐碎的枝节\n6. 随时准备重画\n\n\n\n**分解程度**\n\n\n\n## 数据字典\n\n数据流图 + 数据字典 = 软件逻辑模型\n\n*字典条目的种类*\n\n数据流、文件、数据项、加工、源或宿\n\n*字典数据中使用的描述符号*\n\n![image-20210401185616134](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210401185616.png)\n\n\n\n**字典条目**\n\nDFD中的每个元素都对应一个数据字典条目的描述，不同种类的有不同的描述内容。\n\n1. 数据流条目\n2. 文件条目\n3. 数据项条目\n4. 加工条目\n5. 源或宿条目\n6. 别名条目\n\n\n\n## 描述基本加工的小说明\n\nDFD每个基本加工都用一条小说明进行描述，小说明就是基本加工的加工规约。\n\n加工逻辑的描述方法有结构化语言、判定表和判定树。\n\n\n\n## 结构化设计概述\n\n结构化设计（SD）是将结构化分析得到的数据流图映射成软件体系结构的一种设计方法，SD强调模块化、自顶向下逐步求精、信息隐蔽、高内聚低耦合等设计准则。\n\n\n\n**结构图**\n\n结构化设计方法中用结构图描述软件系统的体系结构，指出一个软件系统由哪些模块组成，以及模块之间的调用关系\n\n\n\n**启发式设计策略**\n\n1. 改造程序结构图，降低耦合度，提高内聚度\n2. 避免高扇出，并随着深度的增加，力求高扇入\n3. 模块的影响范围应限制在该模块的控制范围内\n4. 降低模块结构的复杂程度和冗余程度，提高一致性\n5. 模块的功能应是可预测的，避免对模块施加过多的限制\n6. 尽可能设计单入口和单出口的模块\n\n\n\n**结构化设计的步骤**\n\n1. 建立初始结构图\n2. 对结构图的改进\n3. 书写设计文档\n4. 设计评审\n\n\n\n## 数据流图到软件体系结构的映射\n\n结构化设计是将结构化分析的结果（数据流图）映射成软件的体系结构（结构图）。根据信息流的特点，可将数据流图分为数据流图和事务型数据流图，其对应的映射分别成为变化分析和事务分析。\n\n\n\n**信息流**：变换流和事务流\n\n\n\n**数据流图映射到结构图的步骤**\n\n1. 复审和精细数据流图\n2. 确定数据流图类型\n3. 将DFD映射成初始结构图\n4. 改进初始结构图\n\n\n\n**变换分析**\n\n将变换型的DFD映射成初始的结构图\n\n1. 划定输入流和输出流的边界，确定变换中心\n2. 进行第一级分解\n3. 进行第二级分解\n4. 标注输入输出信息\n\n\n\n**事务分析**：确定事务中心、将DFD映射成事务性的结构图、分解每条动作路径的结构图\n\n\n\n**分层DFD的映射**\n\n\n\n## 初始结构图的改进\n\n技巧：减少模块间的耦合度、消除重复功能、消除”管道模块“、模块大小适中、避免高扇出、考虑全局","categories":["软件工程"]},{"title":"软件工程 第3章 需求工程","url":"/2021/04/01/软件工程-第3章-需求工程/","content":"\n## 需求工程概述\n\n六个阶段：需求获取、需求分析和协商、系统建模、需求规约、需求验证和需求管理。\n\n\n\n## 需求获取\n\n**软件需求**\n\n功能、性能、用户或人的因素、环境、界面、文档、数据、资源使用、安全保密、可靠性、软件成本消耗与进度开发、其他非功能性需求\n\n\n\n**需求获取方法与策略**\n\n建立顺畅的通信路径、访谈与调查、观察用户操作流程、组成联合小组、用例\n\n\n\n## 需求分析、协商与建模\n\n**需求分析原则**\n\n1. 必须能够表示和理解问题的信息域\n2. 必须能够定义软件将完成的功能\n3. 必须能够表示软件的行为（作为外部事件的结果）\n4. 必规划分描述数据、功能和行为的模型， 从而可以分层次地揭示细节\n5. 分析过程应该从要素信息移向细节信息\n\n\n\n**需求协商**\n\n\n\n**需求建模**\n\n- 面向数据流的结构化分析方法（SA）\n- 面向数据结构的分析方法\n- 面向对象的分析方法（OOA）\n\n\n\n## 需求规约与验证\n\n**需求规约**\n\n软件需求规约框架\n\n![image-20210401094558294](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210401094605.png)\n\n\n\n**需求验证**\n\n检验需求是否能反映用户的意愿\n\n\n\n## 需求管理\n\n\n\n","categories":["软件工程"]},{"title":"数据库引论 第四章 关系数据库的规范化设计","url":"/2021/03/30/数据库引论 第四章 关系数据库的规范化设计/","content":"\n## 4.1 关系模式的设计问题\n\n**关系模型的外延和内涵**\n\n- 外延：关系、表或当前值\n- 内涵：对数据的定义以及数据完整性约束（静态约束和动态约束）的定义\n\n\n\n**模式冗余和异常问题**\n\n数据的冗余可能会引起操作异常\n\n\n\n**关系模式的非形式化设计准则**\n\n1. 应尽可能只包含有直接联系的属性\n2. 应尽可能使得相关关系中不出现插入、删除和修改操作异常现象\n3. 应尽可能使得相应关系中避免放置尽可能为空值的属性\n4. 尽可能使得关系的等值连接在主键和外键属性上\n\n\n\n**符号规定**\n\n![image-20210330184801036](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210330184809.png)\n\n## 4.2 函数依赖\n\n**函数依赖（FD）的定义**\n\n关系模式R（U），X和Y是属性集U的子集，函数依赖是形为X->Y的一个命题，只要r是R的当前关系，对r中任意两个元组t和s，都有t[X] = s[X]蕴含t[Y] = s[Y]，那么称FD X -> Y在关系模式R（U）中成立\n\n\n\n**FD的逻辑蕴含**\n\n![image-20210402125442774](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402125442.png)\n\n\n\n**FD的推理规则**\n\nU是关系模式R中的属性集，F是R上成立的只涉及U中属性的函数依赖集，FD的推理规则有以下三条：\n\nA1 自反性 $若Y\\subseteq X \\subseteq U,则X\\rightarrow Y在R上成立$\n\nA2 增广性 $若X\\rightarrow Y,且Z\\subseteq U,则XZ\\rightarrow YZ在R上成立$\n\nA3 传递性 $若X \\rightarrow Y,Y \\rightarrow Z,则 X\\rightarrow Z在R上成立$\n\n\n\n其他五条规则\n\nA4 合并性  $\\lbrace X\\rightarrow Y,X \\rightarrow Z \\rbrace \\models X \\rightarrow YZ $\n\nA5 分解性 $\\lbrace X \\rightarrow Y,Z \\subseteq Y \\rbrace \\models X \\rightarrow Z$\n\nA6 伪传递性 $\\lbrace X \\rightarrow Y, WY \\rightarrow Z \\rbrace \\models WX \\rightarrow Z$\n\nA7 复合性 $\\lbrace X \\rightarrow Y, W \\rightarrow Z \\rbrace \\models XW \\rightarrow YZ$\n\nA8  $\\lbrace X \\rightarrow Y, W \\rightarrow Z \\rbrace \\models X\\bigcup (W - Y) \\rightarrow YZ$\n\n\n\n![image-20210402125908142](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402125908.png)\n\n\n\n**FD和关键码的联系**\n\n*超键和候选键*\n\n![image-20210402151448761](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402151448.png)\n\n\n\n**属性集的闭包**\n\n![image-20210402151645328](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402151645.png)\n\n\n\n**FD推理规则的完备性**\n\n*正确性*：从FD集F使用推理规则集推出的FD必定在F+中\n\n*完备性*：F+中的FD都能从F集使用推理规则导出\n\nFD推理规则{A1,A2,A3}是完备的\n\n\n\n**FD集的最小依赖集**\n\n若F+=G+，则称F和G是等价的函数依赖集\n\n*最小依赖集Fmin*\n\n![image-20210402151940110](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402151940.png)\n\n\n\n## 4.3 模式的分解特性\n\n**模式分解问题**\n\n![image-20210402155820123](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402155820.png)\n\n*泛关系模式*\n\n现实问题的所有属性组成的关系模式（包括属性集和属性集上的数据完整性约束）称为泛关系模式，关系r是关系模式的当前值，是元组的集合，称为泛关系\n\n![image-20210402160117469](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402160117.png)\n\n\n\n**无损分解**\n\nr和$\\sigma$是否等价\n\n![image-20210402160224973](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402160225.png)\n\n*幂等性*\n\n\n\n**无损分解的测试方法**\n\n*算法如下：*\n\n![image-20210404124437456](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210404124444.png)\n\n$$\n定理:设\\rho=\\{R1,R2\\}是关系模式R的一个分解，F是R上成立的FD集，那么分解\\rho相对于F是无损分解的充分条件是\\\\(R1\\bigcap R2)\\rightarrow (R1-R2)(或(R2-R1))\n$$\n\n$$\n定理:如果FD\\,X\\rightarrow Y在模式R上成立，且X\\bigcap Y=\\varphi，\\\\\n那么R分解成\\rho=\\{R-Y,XY\\}是无损分解\n$$\n\n\n\n**保持函数依赖的分解**\n\nF和{F1,F2,...,Fn}是否等价\n\n![image-20210404131605106](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210404131605.png)\n\n\n\n**模式分解与模式等价问题**\n\n两个数据库的等价包括数据等价和依赖等价两个方面\n\n- 数据等价指两个数据库实例应标识同样的信息内容，用“无损分解”衡量。如果是无损分解，那么对泛关系反复的投影和连接都不会丢失信息。\n- 依赖等价是指两个数据库模式有相同的依赖集闭包。在依赖集闭包相等的情况下，数据的语义是不会出差错的。\n\n\n\n\n\n## 4.4 关系模式的范式\n\n**第一范式 1NF**\n\n定义：如果关系模式R的每个关系r的属性值都是不可分的原子值，那么称R是第一范式的模式\n\n满足1NF的称为规范化关系，否则称为非规范化关系\n\n\n\n**第二范式**\n\n![image-20210404132729028](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210404132729.png)\n\n分解成2NF模式集的算法\n\n![image-20210404132814460](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210404132814.png)\n\n\n\n**第三范式**\n\n定义：如果$X\\rightarrow Y,Y\\rightarrow A$，且$Y\\nrightarrow X$ 和$A\\notin Y$，那么称$X\\rightarrow A$是传递依赖（A传递依赖于X）\n\n定义：如果关系模式R是1NF，且每个非主属性都不传递于R的候选键，那么称R是第三范式（3NF）的模式，如果数据库模式种每个关系模式都是3NF，则称其为3NF的数据库模式。\n\n![image-20210404134254589](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210404134254.png)\n\n定理：如果R是3NF模式，那么R也是2NF模式\n\n定理：设关系模式R，当R上每一个FD X->A都满足下列三个条件之一时\n\n1. A∈X\n2. X是R的超键\n3. A是主属性\n\n则关系模式R就是3NF模式\n\n\n\n**BCNF**\n\n定义：如果关系模式R是1NF，且每个属性都不传递依赖于R的候选键，那么称R是BCNF模式。如果数据库模式中每个关系模式都是BCNF，则称为BCNF的数据库模式。\n\n定理：如果R是BCNF模式，那么R也是3NF模式\n\n定义：设F是关系模式R的FD集，如果对F中每个非平凡的FD X->Y，都有X是R的超键，那么称R是BCNF的模式\n\n\n\n![image-20210404134912083](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210404134912.png)\n\n![image-20210404134944537](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210404134944.png)\n\n\n\n**模式设计方法的原则**\n\n- 数据库设计者在进行关系数据库的设计时，应作权衡，尽可能使数据库保持最好的特性。一般尽可能设计成BCNF模式集。如果设计成BCNF模式集时达不到FD的特点，那么只能降低要求，设计成3NF模式集，以求达到保持FD和无损分解的特点。\n- 模式分解并不单指把泛关系模式分解成数据库模式，也可以把数据库模式转换成另一个数据库模式，分解和转换的关键是要“等价”地分解。一个好的模式设计方法应符合三条原则：表达性、分离性和最小冗余性。\n\n\n\n## 4.5 模式的进一步规范化处理\n\nFD还不足以描绘现实世界中数据之间的全部联系，有些联系就要用其他数据来刻画，例如多值依赖或连接依赖。\n\n\n\n*第四范式*\n\n（是4NF的模式肯定是BCNF模式）\n\n\n\n","categories":["数据库"]},{"title":"第七章 快速排序","url":"/2021/03/24/第七章 快速排序/","content":"\n## 快速排序的描述\n\n使用分治的思想，分成三步\n\n1. 分解：分成A[p...q-1]和A[q+1...r]，此时A[q]已经被放在了正确的位置，A[q]：pivot\n2. 解决：通过递归调用对子数组排序\n3. 合并：因为子数组已经有序，故不需要合并操作\n\n```\nQUICKSORT(A,p,r)\nif p < r\n\tq = PARTITION(A,p,r)\n\tQUICKSORT(A,p,q-1)\n\tQUICKSORT(A,q+1,r)\n\t\nPARTITION(A,p,r)\nx = A[r]\ni = p - 1\nfor j = p to r - 1\n\tif A[j] <= x\n\t\ti = i + 1\n\t\texchange A[i] with A[j]\nexchange A[i+1] with A[r]\nreturn i + 1\n```\n\n\n\n## 快速排序的性能\n\n依赖于划分是否平衡，如果平衡，性能近似于归并排序；如果不平衡，性能近似于插入排序\n\n- 最坏情况划分（完全不平衡）\n  $$\n  T(n)=T(n-1)+T(0)+\\Theta(n)\n  $$\n\n  $$\n  T(n)=\\Theta(n^2)\n  $$\n\n  \n\n- 最好情况划分（完全平衡）\n  $$\n  T(n)=2T(n/2)+\\Theta(n)\n  $$\n  \n$$\n  T(n)=\\Theta(n\\lg n)\n  $$\n  \n  \n  \n- 平均情况的划分：平均情况事实上接近于最好情况（例如数组长度9：1时）\n\n\n\n## 快速排序的随机化版本\n\n显示地对输入进行重新排列，使得算法实现随机化\n\n在划分前进行一次交换\n\n```\nRANDOMIZED-PARTITION(A,p,r)\ni = RANDOM(p,r)\nexchange A[r] with A[i]\nreturn PARTITION(A,p,r)\n```\n\n\n\n## 快速排序分析\n\n**最坏情况分析**\n\n$O(n^2)$\n\n\n\n**期望运行时间**\n\n$O(n\\lg n)$\n\n证明过程略","categories":["算法导论"]},{"title":"第六章 堆排序","url":"/2021/03/24/第六章 堆排序/","content":"\n堆排序时间复杂度：$O(n\\lg n)$，和归并排序一样\n\n## 堆\n\n一个近似完全的二叉树\n\n![image-20210324140441665](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210324140442.png)\n\n- 根节点A[1]\n- A[i]的父节点A[$\\lfloor i/2 \\rfloor$]\n- A[i]左子节点A[2i]\n- A[i]右子节点A[2i+1]\n\n\n\n最大堆：子节点小于等于父节点，根节点最大，用于堆排序\n\n(一个叶子节点本身是一个最大堆)\n\n最小堆：子节点大于等于父节点，根节点最小，用于构造优先级队列\n\nn个节点的堆的高度 $\\lfloor \\lg n \\rfloor$\n\n\n\n## 维护堆的性质\n\n最大堆\n\n```\nMAX-HEAPIFY(A,i) // Sub-tree rooted at node i\n\tl = LEFT(i)\n\tr = RIGHT(i)\n\tif l < heap-size[A] and A[l] > A[i]\n\t\tthen largest = l\n\t\telse largest = i\n    if r <= heap-size[A] and A[r] > A[largest]\n    \tthen largest = r\n    if largest != i\n    \tthen exchange A[i] and A[largest]\n    \t\tMAX-HEAPIFY(A,largest)\n```\n\n\n\n## 建堆\n\n```\nBUILD-MAX-HEAP(A)\n heap-size[A] = length[A]\n for i = length[A]/2 downto 1\n  do MAX-HEAPIFY(A,i)\n```\n\n时间代价 $O(n\\lg n)$\n\n\n\n## 堆排序算法\n\n```\nHEAPSORT(A)\n\tBUILD-MAX-HEAP(A)\n\tfor i = length[A] downto 2\n\t\tdo exchange A[1] and A[i]\n\t\t\theap-size[A] = heap-size[A] - 1\n\t\t\tMAX-HEAPIFY(A,1)\n```\n\n时间代价 $O(n\\lg n)$\n\n\n\n## 优先级队列\n\n一种用来维护一组元素构成的集合S的数据结构，其中每个元素有一个关键字key。\n\n支持的操作：\n\n- INSERT(S, x)，把元素x插入集合S中\n- MAXINUM(S)，返回S中具有最大键字的元素\n- EXTRACT-MAX(S)，去掉并返回S中具有最大键字的元素\n- INCREASE-KEYS(S, x, k)，将元素x的关键字增加到k（比原来大）\n\n\n\n\n\n\n\n\n\n\n\n","categories":["算法导论"]},{"title":"数据库引论 第五章 数据库设计和ER模型","url":"/2021/03/23/数据库引论 第五章 数据库设计和ER模型/","content":"\n## 数据库设计概论\n\n数据库生存期：\n\n规划、需求分析、概念设计、逻辑设计、物理设计、实现、运行和维护\n\n\n\n## 数据库设计全过程\n\n**规划**\n\n系统调查、可行性分析、确定数据库系统的总目标和制定项目开发计划\n\n\n\n**需求分析**\n\n- 分析用户活动产生，产生业务流程图（TFD）\n- 确定系统范围，产生系统范围图\n- 分析用户活动涉及的数据，产生数据流图（DFD）\n- 分析系统数据，产生数据字典\n\n\n\n**概念设计**\n\n从每个用户的角度出发定义ER图，然后合并\n\n\n\n**逻辑设计**\n\n根据概念模式转换成逻辑模式、模式评价、修正\n\n\n\n**物理设计**\n\n- 存储记录结构设计\n- 确定数据存放位置\n- 存取方法的设计\n- 完整性和安全性考虑\n- 程序设计\n\n\n\n**数据库实现**\n\n- 用DDL定义数据库结构\n- 组织数据入库\n- 编制与调试应用程序\n- 数据库试运行\n  - 功能测试\n  - 性能测试（时空代价）\n\n\n\n**数据库的运行与维护工作**\n\n- 数据库的转储和恢复\n- 数据库安全性、完整性控制\n- 数据库性能的监督、分析和改进\n- 数据库的重组织和重构造\n\n\n\n## ER模型\n\n**基本元素**：实体、联系、属性、例子\n\n\n\n## ER模型到关系模型的转换\n\n将每个实体类型转换成一个关系模式，实体的属性即为关系模式的属性，实体标识符即为关系模式的键。\n\n二元联系关系的转换：\n\n- 实体联系1：1 ...\n- 实体联系1：N ...\n- 实体联系M：N ...\n\n\n\n## ER模型实例分析\n\n略\n\n\n\n## ER模型的扩充\n\n**弱实体**\n\n例如：职工的亲属的关系依附于职工，是弱实体\n\n**子类实体与超类实体**\n\n继承性、子类本身比超类具有更多属性、子类和超类有相同的标识符\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["数据库"]},{"title":"32位ALU设计","url":"/2021/03/18/32位ALU设计/","content":"\n## 设计思路及代码\n\n```verilog\nmodule ALU32(\nALUcont,A,B,\nzero,result\n\t);\n    input [31:0] A,B;\n    input [2:0] ALUcont;\n    output reg[31:0] result;\n    output reg zero;\n    \nalways@(*)\nbegin\n    case(ALUcont)\n        //AND\n        3'b000:\n            begin\n            result=A&B;\n            zero=(result==0)?1:0;\n            end\n        //OR\n        3'b001:\n            begin\n            result=A|B;\n            zero=(result==0)?1:0;\n            end\n        //+\n        3'b010:\n            begin\n            result=A+B;\n            zero=(result==0)?1:0;\n            end\n        //not used\n        //3'b011:\n        //AND !\n        3'b100:\n            begin\n         \tresult=A&(~B);\n            zero=(result==0)?1:0;\n            end\n        //OR !\n        3'b101:\n            begin\n            result=A|(~B);\n            zero=(result==0)?1:0;\n            end\n        //-\n        3'b110:\n            begin\n            result=A-B;\n            zero=(A==B)?1:0;\n            end\n        //SLT\n        3'b111:\n            begin\n                if(A[31]==1&&B[31]==0)\n                    result=1;\n                else if(A[31]==0&&B[31]==0)\n                    result=0;\n                else \n                    result=(A<B)?1:0;\n                zero=(result==0)?1:0;\n            end\n    endcase\nend\nendmodule        \n    \n```\n\n\n\n\n\n## 测试代码及表格补全\n\n| Test                  | ALUcont  | A        | B               | result          | zero     |\n| --------------------- | -------- | -------- | --------------- | --------------- | -------- |\n| ADD 0+0               | 2        | 00000000 | 00000000        | 00000000        | 1        |\n| ADD 0+(-1)            | 2        | 00000000 | FFFFFFFF        | FFFFFFFF        | 0        |\n| ADD 1+(-1)            | 2        | 00000001 | FFFFFFFF        | 00000000        | 1        |\n| ADD FF+1              | 2        | 000000FF | 00000001        | <u>00000100</u> | <u>0</u> |\n| SUB 0-0               | 6        | 00000000 | 00000000        | 00000000        | 1        |\n| SUB 0-(-1)            | 6        | 00000000 | FFFFFFFF        | 00000001        | 0        |\n| SUB 1-1               | 6        | 00000001 | <u>00000001</u> | <u>00000000</u> | <u>1</u> |\n| SUB 100-1             | 6        | 00000100 | <u>00000001</u> | <u>000000ff</u> | <u>0</u> |\n| SLT 0,0               | 7        | 00000000 | 00000000        | 00000000        | 1        |\n| SLT 0,1               | 7        | 00000000 | <u>00000001</u> | 00000001        | 0        |\n| SLT 0,-1              | 7        | 00000000 | <u>FFFFFFFF</u> | <u>00000000</u> | <u>1</u> |\n| SLT 1,0               | 7        | 00000001 | <u>00000000</u> | <u>00000000</u> | <u>1</u> |\n| SLT -1,0              | 7        | FFFFFFFF | <u>00000000</u> | <u>00000001</u> | <u>0</u> |\n| AND FFFFFFFF,FFFFFFFF | <u>0</u> | FFFFFFFF | FFFFFFFF        | <u>FFFFFFFF</u> | <u>0</u> |\n| AND FFFFFFFF,12345678 | <u>0</u> | FFFFFFFF | 12345678        | 12345678        | 0        |\n| AND 12345678,87654321 | <u>0</u> | 12345678 | 87654321        | <u>02244220</u> | <u>0</u> |\n| AND 00000000,FFFFFFFF | <u>0</u> | 00000000 | FFFFFFFF        | <u>00000000</u> | <u>1</u> |\n| OR FFFFFFFF,FFFFFFFF  | <u>1</u> | FFFFFFFF | FFFFFFFF        | <u>FFFFFFFF</u> | <u>0</u> |\n| OR 12345678,87654321  | <u>1</u> | 12345678 | 87654321        | <u>97755779</u> | <u>0</u> |\n| OR 00000000,FFFFFFFF  | <u>1</u> | 00000000 | FFFFFFFF        | <u>FFFFFFFF</u> | <u>0</u> |\n| OR 00000000,00000000  | <u>1</u> | 00000000 | 00000000        | <u>00000000</u> | <u>1</u> |\n\n\n\n```verilog\nmodule ALU32_test(\n    );\n    reg [2:0] ALUcont;\n    reg [31:0] A,B;\n    wire [31:0] result;\n    wire zero;\n    ALU32 alu(ALUcont,A,B,zero,result); \n    initial\n    begin\n    //add\n        ALUcont=3'b010;\n        A=32'h00000000;\n        B=32'h00000000;\n    #20 A=32'h00000000;\n        B=32'hffffffff;\n    #20 A=32'h00000001;\n        B=32'hffffffff;\n    #20 A=32'h000000ff;\n        B=32'h00000001;\n    //sub\n    #20 ALUcont=3'b110;\n        A=32'h00000000;\n        B=32'h00000000;\n    #20 A=32'h00000000;\n        B=32'hffffffff;\n    #20 A=32'h00000001;\n        B=32'h00000001;\n    #20 A=32'h00000100;\n        B=32'h00000001;\n    //slt\n    #20 ALUcont=3'b111;\n        A=32'h00000000;\n        B=32'h00000000;\n    #20 A=32'h00000000;\n        B=32'h00000001;\n    #20 A=32'h00000000;\n        B=32'hffffffff;\n    #20 A=32'h00000001;\n        B=32'h00000000;\n    #20 A=32'hffffffff;\n        B=32'h00000000;\n    //and\n    #20 ALUcont=3'b000;\n        A=32'hffffffff;\n        B=32'hffffffff;\n    #20 A=32'hffffffff;\n        B=32'h12345678;\n    #20 A=32'h12345678;\n        B=32'h87654321;\n    #20 A=32'h00000000;\n        B=32'hffffffff;\n    //or\n    #20 ALUcont=3'b001;\n        A=32'hffffffff;\n        B=32'hffffffff;\n    #20 A=32'h12345678;\n        B=32'h87654321;\n    #20 A=32'h00000000;\n        B=32'hffffffff;\n    #20 A=32'h00000000;\n        B=32'h00000000;\n    end\nendmodule\n    \n```\n\n## 仿真波形图\n\n![image-20210318081357819](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210318081405.png)","categories":["体系结构实验"]},{"title":"第2章 指令集基本原理","url":"/2021/03/17/第2章 指令集基本原理/","content":"## 指令集体系结构的分类\n\n最主要的区别：CPU用来存储操作数的存储单元类型\n\n- 堆栈：堆栈结构\n\n- 累加器：累加器结构\n\n- 通用寄存器：通用寄存器结构（主流结构）\n  - 寄存器-寄存器型（RR） / load-store结构\n  - 寄存器-存储器型（RM）\n  - 存储器存储器型（MM）\n\n![image-20210312101629435](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210312101636.png)\n\n根据操作数特征细分：\n| ALU指令中存储器操作数的个数 | ALU指令中操作数的最多个数 | 结构类型 | 实例 |\n| --------------------------- | ------------------------- | -------- | ---- |\n| 0                           | 3                         | RR       | MIPS |\n| 1                           | 2                         | RM       | x86  |\n| 2                           | 2                         | MM       | VAX  |\n| 3                           | 3                         | MM       | VAX  |\n\n\n\n## 存储器寻址\n\n![image-20210312103527682](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210312103527.png)\n\n- 最常用的是较小立即数（有时候也会用到较大立即数，如地址计算）\n- 指令集结构设计中，至少要将立即数大小设置为8~16位\n\n\n\n## 操作数的类型与大小\n\n由指令中的操作码指定操作数的类型\n\n**大小**：操作数的位数/字节数（字节8位，半字16位，字32位，双字64位）\n\n**类型**：字符（ASCII码表示，一个字节大小）、整数（用二进制补码表示，大小可以是字节、半字或单字）、浮点操作数（单精度1个字，双精度双字，IEEE 754标准）\n\n\n\n十进制操作数类型：\n\n- 压缩十进制或二进制编码十进制\n- 非压缩十进制：字符串表示\n\n\n\n## 指令集中的操作\n\n![image-20210319084140600](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210319084147.png)\n\n\n\n## 控制流指令\n\n- 跳转\n- 分支（占控制流的大部分）\n- 过程调用\n- 过程返回\n\n\n\n## 指令集编码\n\n变长编码格式（适合寻址方式和操作种类很多时）、定长编码格式（适用于寻址方式和操作类型非常少时）、混合型编码格式\n\n\n\n## 指令设计风格\n\n- 复杂指令集计算机CISC\n- 精简指令集计算机RISC\n\n\n\n## MIPS体系结构\n\n**寄存器**\n\n- 32个64位通用寄存器（GPRS） R0...R31\n- 32个64位浮点数寄存器（FPRS)   F0...F31\n\n- 一些特殊寄存器，如浮点状态寄存器\n\n功能定义\n\n\n\n**数据类型**\n\n- 整数\n- 浮点数\n\n\n\n**寻址方式**\n\n立即数寻址和偏移量寻址，字段都是16位\n\n\n\n**指令格式**\n\n寻址方式编码到操作码中，所有指令都是32位，操作码占6位，3种指令格式\n\n- I类：load、store\n- R类：ALU指令、专用寄存器读/写指令、move指令\n- J类：跳转、跳转并链接、自陷指令、异常返回指令\n\n\n\n![image-20210319102420235](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210319102420.png)\n\n\n\n**MIPS操作**\n\n- load和store\n- ALU操作\n- 分支与跳转\n- 浮点操作","categories":["计算机体系结构"]},{"title":"单周期CPU设计","url":"/2021/03/17/单周期CPU设计/","content":"\n## 项目代码\n\n```verilog\n//单周期mips处理器\nmodule mips(input logic clk,reset,\n            output logic[31:0] pc,\n            input logic[31:0] instr,\n            output logic memwrite,\n            output logic[31:0] aluout,writedata,\n            input logic[31:0] readdata);\n    logic\tmemtoreg,alusrc,regdst,\n    \t\tregwrite,jump,pcsrc,zero;\n    logic[2:0] alucontrol;\n    \n    controller c(instr[31:26],instr[5:0],zero,\n                memtoreg,memwrite,pcsrc,\n                alusrc,regdst,regwrite,jump,\n                 alucontrol);\n    datapath dp(clk,reset,memtoreg,pcsrc,\n               alusrc,regdst,regwrite,jump,\n               alucontrol,\n               zero,pc,instr,\n                aluout,writedata,readdata);\nendmodule\n\n//控制器\nmodule controller(input logic[5:0] op,funct,\n                  input logic zero,\n                  output logic memtoreg,memtowrite,\n                  output logic pcsrc,alusrc,\n                  output logic regdst,regwrite,\n                  output logic jump,\n                  output logic[2:0] alucontrol);\n    logic[1:0] aluop;\n    logic branch;\n    \n    maindec md(op, memtoreg,memwrite,brach,\n               alusrc,regdst,regwrite,jump,aluop);\n    \n    aludec ad(funct,aluop,alucontrol);\n    \n    assign pcsrc=branch&zero;\n    \nendmodule\n\n//主译码器\nmodule maindec(input logic[5:0] op,\n               output logic memtoreg,memwrite,\n               output logic branch,alusrc,\n               output logic regdst,regwrite,\n               output logic jump,\n               output logic[1:0] aluop);\n    logic[8:0] controls;\n    \n    assign {regwrite,regdst,alusrc,branch,memwrite,\n            memtoreg,jump,aluop}=controls;\n    \n    always_comb\n        case(op)\n            6'b000000:controls<=9'b110000010;//RTYPE\n            6'b100011:controls<=9'b101001000;//LW\n            6'b101011:controls<=9'b001010000;//SW\n            6'b000100:controls<=9'b000100001;//BEQ\n            6'b001000:controls<=9'b101000000;//ADDI\n            6'b000010:controls<=9'b000000100;//J\n            default:controls<=9'bxxxxxxxxx;//illegle op\n        endcase\nendmodule\n                \n//ALU译码器\nmodule aludec(input logic[5:0] funct,\n              input logic[1:0] aluop,\n              output logic[2:0] alucontrol);\n    always_comb\n        case(aluop)\n            2'b00:alucontrol <= 3'b010;\n            2'b01:alucontrol <= 3'b110;\n            default:case(funct)\n                6'b100000:alucontrol <= 3'b010;\n                6'b100010:alucontrol <= 3'b110;\n                6'b100100:alucontrol <= 3'b000;\n                6'b100101:alucontrol <= 3'b001;\n                6'b101010:alucontrol <= 3'b111;\n                default: alucontrol <= 3'bxxx;\n                endcase\n            endcase\nendmodule\n\n//数据路径\nmodule datapath(input logic clk,reset,\n                input logic memtoreg,pcsrc,\n                input logic alusrc,regdst,\n                input logic regwrite,jump,\n                input logic [2:0] alucontrol,\n                output logic zero,\n                output logic [31:0] pc,\n                input logic [31:0] instr,\n                output logic [31:0] aluout,writedata,\n                input logic [31:0] readdata);\n    logic[4:0] writereg;\n    logic[31:0] pcnext,pcnextbr,pcplus4,pcbranch;\n    logic[31:0] signimm,signimmsh;\n    logic[31:0] srca,srcb;\n    logic[31:0] result;\n    \n    //next PC logic\n    flopr #(32) pcreg(cllk,reset,pcnext,pc);\n    adder\t\tpcaddl(pc,32'b100,pcplus4);\n    s12\t\t\timmsh(signimm,signimmsh);\n    adder\t\tpcadd2(pcplus4,pcbranch,pcsrc,pcnextbr);\n    mux2#(32)\tpcbrmux(pcplus4,pcbranch,pcsrc,pcnextbr);\n    mux2#(32)\tpcmux(pcnextbr,pcplus4[31:28],\n                      instr[25:0],2'b001,jump,pcnext);\n    \n    //register file logic\n    regfile\t\trf(clk,regwrite,instr[25:21],instr[20:16],\n                   writereg,result,srca,writedata);\n    mux2#(5)\twrmux(instr[20:16],instr[15:11],\n                      regdst,writereg);\n    mux2#(32)\tresmux(aluout,readdata,memtoreg,result);\n    signext\t\tse(instr[15:0],signimm);\n    \n    //ALU logic\n    mux2#(32)\tsrcbmux(wirtedata,signimm,alusrc,srcb);\n    alu\t\t\talu(srca,srcb,alucontrol,aluout,zero);\nendmodule\n\n//寄存器文件\nmodule regfile(input logic\tclk,\n               input logic\twe3,\n               input logic[4:0] ra1,ra2,wa3,\n               input logic[31:0] wd3,\n               output logic[31:0] rd1,rd2);\n    logic[31:0]rf[31:0];\n    \n    //three ported register file\n    //read two ports combinationally\n    //write third port combiantionally\n    //register 0 hardwired to 0\n    //note: for piedlined processer, write third port\n    //on falling edge of clk\n    \n    always_ff@(posedge clk)\n        if(we3) rf[wa3]<=wd3;\n    \n    assign rd1=(ra1 !=0)?rf[ra1]:0;\n    assign rd2=(ra2 !=0)?rf[ra2]:0;\nendmodule\n\n//加法器\nmodule adder(input logic[31:0]a,b,\n             output logic[31:0]y);\n    assign y=a+b;\nendmodule\n\n//左移二位（乘以4）\nmodule s12(input logic[31:0] a,\n           output logic[31:0] y);\n    //shift left by 2\n    assign y={a[29:0],2'b00};\nendmodule\n\n//符号扩展\nmodule signext(input logic[15:0] a,\n               output logic[31:0] y);\n    assign y={{16{a[15]}},a};\nendmodule\n\n//可复位触发器\nmodule flopr #(parameter WIDTH=8)\n        (input logic clk,reset,\n         input logic[WIDTH-1:0]d,\n         output logic[WIDTH-1:0]q);\n    always_ff!(posedge clk, posedge reset)\n        if(reset) q<=0;\n        else\tq<=d;\nendmodule\n\n//复用器\nmodule mux2 #(parameter WIDTH=8)\n            (input logic[WIDTH-1:0]d0,d1,\n             input logic s,\n             output logic[WIDTH-1:0]Y);\n    assign y=s?d1:d0;\nendmodule\n```\n\n\n\n## 测试程序\n\n```verilog\n//MIPS基准测试程序\nmodule testbench();\n    logic clk;\n    logic reset;\n    \n    logic[31:0] writedata,datadr;\n    logic\t\tmemewrite;\n    \n    top dut(clk,reset,writedata,datadr,memwrite);\n    \n    initial\n        begin\n            reset <= 1; #22; reset <= 0;\n        end\n    \n    always\n        begin\n            clk <= 1; #5; clk <= 0; #5;\n        end\n    \n    always@(negedge clk)\n        begin\n            if(memwrite) begin\n                if(datadr===84 & writedata===7) begin\n                    $display(\"Simulation succeeded\");\n                    $stop;\n                end else if(datadr !== 80) begin\n                    $display(\"Simulation failed\");\n                    $stop;\n                end\n            end\n        end\nendmodule\n\n//MIPS顶层模块\nmodule top(input logic clk,reset,\n           output logic[31:0] writedata,datadr,\n           output logic memwrite);\n    logic[31:0] pc,instr,readdata;\n    \n    mips mips(clk,reset,pc,instr,memwrite,dataadr,\n              writedata,readdata);\n    imem imem(pc[7:2], instr);\n    dmem dmem(clk,memwrite,dataadr,writedata,readdata);\nendmodule\n\n//MIPS数据存储器\nmodule dmem(input logic clk,we,\n            input logic[31:0] a,wd,\n            output logic[31:0] rd);\n    logic[31:0] RAM[63:0];\n    \n    assign rd=RAM[a[31:2]];\n    \n    always_ff@(posedge clk)\n        if(we) RAM[a[31:2]] <= wd;\nendmodule\n\n//MIPS指令存储器\nmodule imem(input logic[5:0] a,\n            output logic[31:0] rd);\n    logic[31:0] RAM[63:0];\n    \n    initial\n        $readmemh(\"memfile,dat\",RAM);\n    assign rd=RAM[a];\nendmodule\n```\n\n*测试数据(memfile.dat)*\n\n```\n20020005\n2003000c\n2067fff7\n00e22025\n00642824\n00a42820\n10a7000a\n0064202a\n10800001\n20050000\n00e2202a\n00853820\n00e23822\nac670044\n8c020050\n08000011\n20020001\nac020054\n```\n\n\n\n## IO接口的设计\n\n```verilog\nmodule IO(input logic\tclk,\n\t\t  input logic\treset,\n\t\t  input logic\tpRead,\n\t\t  input logic\tpWrite,\n\t\t  input logic[1:0]\tadder,\n\t\t  input logic[31:0] pWriteData,\n\t\t  input logic[31:0] pReadData,\n\t\t  input logic\tbuttenL,\n\t\t  input logic\tbuttenR,\n\t\t  input logic[15:0] switch,\n\t\t  output logic[11:0] led);\n    \n    logic [1:0] status;\n    logic [15:0] switch1;\n    logic [11:0] led1;\n    \n    always_ff @(posedge clk) begin\n        if (reset) begin\n            status\t<=\t2'b00;\n            led1\t<=\t12'h00;\n            switch1\t<=\t16'h00;\n        end\n        else begin\n            // 开关位置已经换好，可以输入新数据\n            if (buttonR) begin\n                status[1] <= 1;\n                switch1\t<= switch;\n            end\n            \n            // LEDs已经准备好，可以输出新数据\n            if (buttonL) begin\n                status[0] <= 1;\n                led\t\t<= led1;\n            end\n            \n            // 向数据输入端口输出(LED)\n            if (pWrite & (addr == 2'b01)) begin\n                led1\t<= pWriteData[11:0];\n                status[0]\t<= 0;\n            end\n            \n            // 读数据\n            if (pRead) begin\n                case(addr)\n                    2'b11:\tpReadData <= {24'b0, switch1[15:8]};\n                    2'b10:\tpReadData <= {24'b0, swtich1[7:0]};\n                    2'b00:\tpReadData <= {24'b0, 6'b000000, status};\n                    default: pReadData <= 32'b0;\n                endcase\n            end\n        end\n    end\nendmodule\n                \n```\n\n\n\n","categories":["体系结构实验"]},{"title":"第3章 流水线","url":"/2021/03/17/第3章 流水线/","content":"\n## 流水线基础知识\n\n- 把一个重复的过程分解为若干个子过程， 每个子过程由专门的功能部件来实现。（并行进行）\n- 每个子过程及其功能部件：流水级/段；段数：流水线的深度\n\n例：\n\n指令流水线\n\n![image-20210326083341631](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210326083341.png)\n\n浮点加法流水线\n\n![image-20210326083424707](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210326083424.png)\n\n\n\n**时空图**\n\n横轴时间、纵轴各个段\n\n![image-20210326083525954](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210326083526.png)\n\n**特点**\n\n- 各段时间应该尽量相等，时间长的段将成为流水线的瓶颈\n- 每个功能部件后面要有一个缓冲寄存器（流水寄存器），用于在相邻两段之间传送数据\n- 通过时间和排空时间\n\n\n\n### 流水线的分类\n\n1. 单功能与多功能流水线\n2. 静态与动态流水线：按同一时间能否执行多种功能对多功能流水线的分类\n3. 线性与非线性流水线：前者没有反馈回路、穿行连接，后者有反馈回路\n4. 顺序流水线和乱序流水线：前者流入流出顺序相同，后者可以后进的先完成\n\n\n\n### 流水线的性能指标\n\nk段流水线，n个任务、$\\Delta{t}$表示执行时间\n\n**吞吐率**\n\n单位时间内流水线所完成的任务/输出结果数量\n\n$TP=\\frac{n}{T_k}$\n\n各段时间相等：\n\n![image-20210326090245212](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210326090245.png)\n$$\nTP=\\frac{n}{(k+n-1)\\Delta{t}}\n$$\n最大吞吐率\n$$\nTP_{max}=\\lim_{n\\rightarrow+\\infty}\\frac{n}{(k+n-1)\\Delta{t}}=\\frac{1}{\\Delta{t}}\n$$\n\n\n各段时间不完全相等：\n\n最长的叫瓶颈段\n\n![image-20210326091005492](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210326091005.png)\n$$\nTP=\\frac{n}{\\sum_{i=1}^{k}\\Delta{t_i}+(n-1)max(\\Delta{t_1},\\Delta{t_2},\\cdots,\\Delta{t_k})}\n$$\n最大吞吐率\n$$\nTP_{max}=\\frac{1}{max(\\Delta{t_1},\\Delta{t_2},\\cdots,\\Delta{t_k})}\n$$\n解决瓶颈问题：细分瓶颈段、重新设置瓶颈段\n\n\n\n**加速比**\n\n同一批任务，使用和不使用流水线时间比\n$$\nS=\\frac{T_s}{T_k}\n$$\n各段时间相等：\n$$\nS=\\frac{nk}{k+n-1}\n$$\n不完全相等：\n$$\nS=\\frac{n\\sum_{i=1}^{k}\\Delta{t_i}}{\\sum_{i=1}^{k}\\Delta{t_i}+(n-1)max(\\Delta{t_1},\\Delta{t_2},\\cdots,\\Delta{t_k})}\n$$\n\n\n\n**效率**\n\n设备利用率\n\n各段时间相等\n$$\nE=\\frac{n}{k+n-1}\n$$\n\n$$\nE_{max}=1\n$$\n\n各段不相等\n$$\nE=\\frac{n\\sum_{i=1}^{k}\\Delta{t_i}}{k[\\sum_{i=1}^{k}\\Delta{t_i}+(n-1)max(\\Delta{t_1},\\Delta{t_2},\\cdots,\\Delta{t_k})]}\n$$\n\n\n\n### 一个经典的5段流水线\n\n非流水情况下，一条指令的执行过程分为以下5个周期\n\n1. 取指令周期（IF）\n2. 指令译码/读寄存器周期（ID）\n3. 执行/有效地址计算周期（EX）\n4. 存储器访问/分支完成周期（MEM）\n5. 写回周期（WB）\n\n\n\n改为流水线实现：\n\n- 每个周期作为一个流水段\n- 各段之间加上锁存器\n\n![image-20210326102646310](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210326102646.png)\n\n\n\n## 流水线冒险\n\n流水线冒险会阻止指令流中下一条指令不能在指定的时钟周期执行\n\n- 结构冒险：因硬件资源满足不了指令重叠执行的要求而出现资源冲突，导致结构冒险\n- 数据冒险：当指令在流水线中重叠执行时，因需要用到前面指令的执行结果，导致数据冒险\n- 控制冒险：流水线遇到分支指令和其他会改变PC值的指令，导致控制冒险\n\n\n\n### 带有停顿的流水线性能\n\n![image-20210402083338983](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402083346.png)\n\n### 结构冒险\n\n常见原因：功能部件不是完全流水、资源份数不够\n\n解决办法：插入暂停周期（“气泡”）、设置相互独立的指令存储器和数据存储器或设置相互独立的指令Cache和数据Cache\n\n\n\n### 数据冒险\n\n当相关的指令靠得足够近时，它们在流水线中的重叠执行或者重新排序会改变指令读写操作数的顺序，使之不同于它们非流水实现时的顺序，则发生了数据冒险。\n\n- 通过转发技术（旁路/短路）减少数据冒险引起的停顿\n\n- 增加流水线互锁硬件、插入“停顿”（或气泡）\n\n\n\n### 分支冒险\n\n- *降低流水线分支代价*\n\n处理分支指令最简单的方法：“冻结”流水线，保留或删除分支之后的所有指令，直到直到分支目标地址。\n\n- *预测未选中（预测分支失败）*\n\n- *预测选中（预测分支成功）*\n\n\n\n*分支延迟指令的调度*\n\n在延迟槽中放入有用的指令，由编译器完成，能否带来好处取决于编译器能否把有用的指令调度到延迟槽中。\n\n![image-20210402102005229](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402102005.png)\n\n\n\n\n### 分支预测\n\n通过预测降低分支成本\n\n- 静态分支预测：利用编译时可用信息的低成本静态机制\n- 动态分支预测：根据程序特性对分支进行动态预测的策略\n\n\n\n## 实现流水化\n\n### MIPS的简单实现\n\n一条MIPS指令最多需要以下5个时钟周期\n\n*取指令周期（IF）*\n\n*指令译码/读寄存器周期（ID）*\n\n*执行/有效地址计算周期（EX）*\n\n*存储器访问/分支完成周期（MEM）*\n\n*写回周期（WB）*\n\n![image-20210402102601455](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402102601.png)\n\n\n\n### MIPS基本流水线\n\n每一个时钟周期完成的工作看作是流水线的一段，每个时钟周期启动一条新的指令。\n\n段和段之间设置流水寄存器，命名：用其相邻的两个段的名称拼合而成\n\n![image-20210402103053923](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402103054.png)\n\n### MIPS流水线的控制\n\n*控制四个多路选择器*\n\n*解决数据冒险的问题*\n\n![image-20210402103316278](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402103316.png)\n\n\n\n### 处理流水线中的分支\n\n![image-20210402103408763](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210402103408.png)","categories":["计算机体系结构"]},{"title":"第五章 概率分析和随机算法","url":"/2021/03/17/第五章 概率分析和随机算法/","content":"## 5.1 雇佣问题\n\n```\nHIRE-ASSISTANT(n)\nbest = 0\nfor i = 0 to n\n\tinterview candidate i\n\tif candidate is better than candidate best\n\t\tbest = i\n\t\thire candidate i\n```\n\n**最坏情形分析**\n\n应聘者质量按出现的次序严格递增\n\n如何求平均情况？\n\n**随机算法**\n\n\n\n## 5.2 指示器随机变量\n\n定义：\n$$\nI\\lbrace A\\rbrace=\\begin{cases} 1\\quad如果A发生\\\\\n0\\quad如果A不发生\\end{cases}\n$$\nA发生的概率$Pr\\lbrace A\\rbrace$，期望 $E[X_A]$\n\n引理：给定一个样本空间S和S中的一个事件A，设$X_A=I\\lbrace A\\rbrace$，那么$E[X_A]=Pr\\lbrace A\\rbrace$\n\n**用指示器随机变量分析雇佣问题**\n$$\nX_i=I\\lbrace 应聘者i被雇佣\\rbrace = \\begin{cases} 1\\quad如果应聘者i被雇佣 \\\\ 0\\quad如果应聘者i不被雇佣  \\end{cases}\n$$\n\n\n以及\n$$\nX=X_1+X_2+\\cdots+X_n\n$$\n\n\n根据引理\n$$\nE[X_i]=Pr\\lbrace 应聘者i被雇佣\\rbrace \n$$\n\n\n应聘者比应聘者1到i-1更有资格的概率是1/i，因此\n$$\nE[X_i]=1/i\n$$\n计算得\n$$\nE[X]=\\ln n+O(1)\n$$\n因此尽管面试了n个人，实际上大约只雇佣他们之中的$\\ln n$个人\n\n\n\n## 5.3 随机算法\n\n先对应聘者进行排列，然后确定最佳应聘者的随机算法。此时建立的算法的性能和假设应聘者以随即次序出现所得的结果是匹配的。\n\n**随机排列数组**\n\n```\nPERMUTE-BY-SORTING(A)\nn=A.length\nlet P[1...n] be a new array\nfor i = 1 to n\n\tP[i] = RANDOM(1, n^3)\nsort A, using P as sort keys\n```\n\n引理：假设所有优先级都不同，则过程PERMUTE-BY-SORTING产生输入的均匀随机排列\n\n另一个方法：原址排列给定数组\n\n```\nRANDOMIZE-IN-PLACE(A)\nn = A.length\nfor i = 1 to n\n\tswap A[i] with A[RANDOM(i, n)]\n```\n\n\n\n\n\n","categories":["算法导论"]},{"title":"概论","url":"/2021/03/17/概论/","content":"## 1.1 计算机软件\n\n1. 软件的发展\n\n- 1946~1956 第一个程序的出现到高级语言出现\n\n- 1956~1986 高级语言出现到软件工程出现\n\n- 1968至今\n\n2.  软件的特点\n\n一种逻辑实体、被开发或设计、不会老化，但需要修复。\n\n3. 软件的分类\n\n- 系统软件：编译程序、操作系统等\n\n- 支撑软件：数据库管理系统等\n\n- 应用软件：Web应用软件等\n\n4. 软件语言\n\n- 需求定义语言：PSL/PSA\n\n- 功能性语言：Z语言\n\n- 设计性语言：PDL\n\n- 实现性语言：\n\n  - 低级语言和高级语言\n\n  - 过程语言和非过程语言\n\n  - ...\n\n- 文档语言\n\n## 1.2 软件工程\n\n- 定义：软件工程是应用计算机科学、数学及管理科学等原理，开发软件的工程。\n- 软件工程框架：目标、过程和原则。\n- 软件的生存周期：计算机系统工程->需求分析->设计->编码->测试->运行和维护\n\n##  1.3 软件过程\n\n能力成熟度模型CMM和能力成熟度模型集成CMMI\n\n## 1.4 软件过程模型\n\n- 瀑布模型\n- 演化模型\n- 增量模型\n- 原型模型螺旋模型\n- 喷泉模型\n- 基于构件的开发模型\n- 形式化方法模型\n\n## 1.5 敏捷软件开发\n\n1. 敏捷软件开发的价值观及开发原则\n   - 个人和交互高于过程和工具\n   - 可运行软件高于详尽的文档\n   - 与客户协作高于合同谈判\n   - 对变更及时作出反应高于遵循计划\n2. XP方法\n3. Agile和CMM\n\n## 1.6 CASE工具和环境\n\n\n\n\n","categories":["软件工程"]},{"title":"Hexo报错","url":"/2021/03/17/Hexo报错/","content":"\n今天在使用hexo博客运行 hexo d 出现报错\n\n```\n OpenSSL SSL_connect: Connection was reset in connection to github.com:443\n```\n\n 查询了很多方案后，发现是代理的问题，如果你使用了VPN，需要设置一下http.proxy，先查看端口号\n\n![image-20210317125154852](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210317125202.png)\n\n我的端口号是2802，设置http.proxy\n\n```\ngit config --global http.proxy 127.0.0.1:2802\ngit config --global https.proxy 127.0.0.1:2802\n```\n\n如果之前已经有过设置，先取消\n\n```\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n```\n\n设置好之后再hexo d，部署成功\n\n附上我的报错和解决截图\n\n![image-20210317125426084](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210317125426.png)","categories":["工具"]},{"title":"第四章 分治策略","url":"/2021/03/17/第四章 分治策略/","content":"Divide-Conquer-Combine\n\n## 4.1 最大子数组问题\n\n``` java\nFIND-MAX-CROSSING-SUBARRAY(A,low,mid,high) \n    /*\n    接受数组A和下表low,mid,high为输入，\n    返回一个下标元组划定跨越种点的最大子数组的边界，并返回最大子数组中值的和\n    */\nleft-sum = -∞\nsum = 0\nfor i = mid downto low\n    sum = sum + A[i]\n    if sum > left - sum\n        left-sum = sum\n        max-left = i\nright-sum = -∞\nsum = 0\nfor j = mid + 1 to high\n    sum = sum + A[j]\n    if sum > right-sum\n        right-sum = sum\n        max-right = j\nreturn(max-left, max-right, left-sum + right-sum)\n\nFIND-MAXIMUM-SUBARRAY(A,low,high) //求出A[1...n]的最大子数组\nif high == low\n    return (low,high,A[low])\nelse mid = (low + high)/2\n    (left-low, left-high, left-sum) = \n    \tFIND-MAXIMUM-SUBARRAY(A,low,mid)\n    (right-low, right-high, right-sum) = \n    \tFIND-MAXIMUM-SUBARRAY(A,mid+1,high)\n    (cross-low, cross-high, cross-sum) = \n    \tFIND-MAX-CROSSING-SUBARRAY(A,low,mid,high)\n    if left-sum >= cross-sum and right-sum >= cross-sum\n        return(left-low, left-high, left-sum)\n    else right-sum >= cross-sum and right-sum >= cross-sum\n        return(right-low, right-high, right-sum)\n    else return(cross-low, cross-high, cross-sum)\n\n```\n\n\n## 4.2 矩阵乘法的Strassen算法\n\n常规算法花费Θ(n^3)，Strassen算法花费Θ(n^lg7)≈Θ(n^2.81)\n\n基本思想：减少多余的乘法，把乘法变成乘法+加法\n\n\n\n\n## 4.3 代入法求解递归式\n\n**步骤**\n\n1. 猜测解的形式\n2. 用数学归纳法求出解种的常数，并证明解是正确的\n\n\n\n## 4.4 递归树方法求解递归式\n\n将递归式转换成一棵树，其节点表示不同层次的递归调用产生的代价。然后采用边界和技巧来求解递归式。\n\n\n\n## 4.5 主方法求解递归式\n\n求解形式如 $T(n)=aT(n/b)+f(n)$递归式的界\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["算法导论"]},{"title":"数据库引论 第三章 关系数据库语言-SQL","url":"/2021/03/16/数据库引论 第三章 关系数据库语言-SQL/","content":"\n## SQL体系结构：\n\n![](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210309194458.png)\n\n\n\n## SQL的数据定义\n\n**SQL模式的创建和撤销**\n\n```sql\nCREATE SCHEMA <模式名> AUTHORIZATION <用户名> //创建\nDROP SCHEMA <模式名> [CASCADE|RESTRICT] //删除\n```\n\nCASCADE级联式，直接删除；RESTRICT约束式，若模式下面有其他模式，则提示\n\n\n\nSQL基本数据类型：数值型、字符串型、位串型、时间型\n\n\n\n**基本表的创建**、**修改和撤销**：\n\n```sql\n//创建\nCREATE  TABLE  S\n\t\t\t(S#\t    CHAR(4)  NOT  NULL,\n\t\t\t SNAME  CHAR(8)  NOT  NULL,\n\t\t\t AGE\tCHAR(1),\n\t\t\t SEX    CHAR(1),\n  \t\t PRIMARY  KEY(S#));\n//修改\nALTER TABLE <基本表名> ADD <列名> <类型> \n//删除\nALTER TABLE <基本表名> DROP <列名>［CASCADE│RESTRICT］\n//修改某个列\nALTER  TABLE  S  MODIFY  S#  CHAR(6)\n//删除表\nDROP TABLE <基本表名>［CASCADE│RESTRICT］\n```\n\n- CASCADE表示删除时自动删除该列的视图和约束，RESTRICT则拒绝删除\n- CAHR提前给一个固定的地址大小，VARCHAR根据实际情况调整大小（在范围内）\n\n\n\n**索引的创建和撤销**：\n\n```sql\n//创建\nCREATE ［UNIQUE］ INDEX  <索引名> ON  <基本表名>(列名表) \n//撤销\nDROP  INDEX  <索引名>\n```\n\n\n\n## SQL的数据查询\n\n**SELECT查询语句**\n\n- SELECT-FROM-WHERE句型\n- WHERE子句的条件表达式可用的运算符\n  - 算数比较 <...\n  - 逻辑 AND...\n  - 集合成员资格 IN...\n  - 谓词 EXISTS...\n  - 聚合函数 AVG...\n  - 另一个SELECT语句嵌套\n  - 集合 UNION...\n\n\n\n**SLECT语句的图示化**\n\n（C2是常量，P是要打印的数据）\n\n![image-20210316183152291](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210316183159.png)\n\n\n\n**聚合函数**\n\n- COUNT(*) 计算元组个数  \n- COUNT(列名) 对一列中的值计算个数\n- SUM(列名) 对某一列的值的总和\n- AVG\n- MAX\n- MIN\n- ...\n\n\n\n**其他**\n\n- *表示所有的列\n- DISTINCT取出不同的\n\n\n\n**SELECT完整语句**\n\n```sql\nSELECT 目标表的列名或列表达式序列\nFROM 基本表名和（或）视图序列\n[WHERE 行条件表达式]\n [GROUP BY 列名序列 ]\n   [HAVING 组条件表达式 ]\n [ORDER BY 列名[ASC|DESC]，…]\n```\n\n\n\n**基本表的连接**\n\n| 连接类型                   | 连接条件            |\n| -------------------------- | ------------------- |\n| INNER JOIN 内连接          | NATURAL             |\n| LEFT OUTER JOIN 左外连接   | ON 等值连接条件     |\n| RIGHT OUTER JOIN 右外连接  | USING(A1,A2,...,An) |\n| FULL OUTER JOIN 完全外连接 |                     |\n\n\n\n**递归查询**\n\n假设课程有先修与后继的联系\n\nCOURSE(C#,CNAME,PC#)\n\n设临时关系W（C#，PC#）的属性表示课程号、直接或间接先修课的课程号。求W，可以利用这样两个规则：\n\n**① W(x,y)← COURSE(x,u,y)**\n\n**② W(x,y)← COURSE(x,u,z)∧ W(z,y)**\n\n```sql\nWITH RECURSIVE W(C#, PC#) AS\n\t\t(SELECT C#, PC# FROM COURSE)\n    UNION\n        (SELECT W1.C#, W2.PC#\n        FROM COURSE AS W1, W AS W2\n        WHERE W1.PC#=W2.C#)\n    SELECT * FROM W;\n```\n\n\n\n## 数据更新\n\n**数据插入**\n\n- 单元组插入\n\n   INSERT INTO基本表名[(列名表)] VALUES(元组值)\n\n- 多元组插入\n\n  INSERT INTO 基本表名 [(列名表)]\n\n  VALUES (元组值),(元组值)，……，(元组值)\n\n- 查询结果插入\n\n  INSERT INTO 基本表名 [(列名表)]<SELECT查询语句>\n\n- 表的插入\n\n  INSERT INTO 基本表名1[(列名表)]TABLE 基本表名2\n  \n  \n\n**数据删除**\n\nDELETE FROM 基本表名\n\n[WHERE 条件表达式]\n\n\n\n**数据修改**\n\nUPDATE\n\n\n\n## 视图的定义和对视图的操作\n\n**视图的创建和撤销**\n\n```sql\n\nCREATE VIEW <视图名>（列表名）\n\nAS <SELECT 查询语句>\n\n```\n\n视图实际上对应一个查询语句\n\nDROP VIEW\n\n\n\n**对视图的更新操作**\n\n如果视图是从单个基本表只使用选择、投影操作导出的，并且包含了基本表的主键，那么这样的视图称为*行列子集视图*，并且可以被执行更新操作。\n\n\n\n**视图的优点**\n\n1. 视图提供了逻辑数据独立性\n2. 简化了用户观点\n3. 数据的安全保护功能\n\n\n\n## 嵌入式SQL\n\nSQL的两种使用方式：\n\n1. 终端交互方式下使用：交互式SQL\n2. 嵌入高级语言的程序中使用：嵌入式SQL\n\n\n\n**SQL的运行环境**\n\n![image-20210316202531831](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210316202532.png)\n\n**嵌入式SQL的使用规定**\n\n允许嵌入的SQL语句引用宿主语言的程序变量（称为共享变量）\n\n- 游标定义语句 DECLARE\n- 游标打开语句 OPEN\n- 游标推进语句 FETCH\n- 游标关闭语句 CLOSE\n\n\n\n**嵌入式SQL的使用技术**\n\n1. 不涉及游标的SQL DML语句\n2. 设计游标的SQL DML语句\n3. 卷游标的定义和推进\n\n\n\n**动态SQL语句**\n\nEXEC SQL PREPARE <动态SQL语句名>\n\nFROM <共享变量或字符串>\n\n这个语句可以在程序运行时由用户输入才组合起来\n\n\n\n**ODBC**\n\n公共接口API\n\nODBC程序的基本流程\n\n![image-20210316205638625](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210316205638.png)","categories":["数据库"]},{"title":"数据库引论  第二章 关系运算模型和关系运算理论","url":"/2021/03/15/数据库引论 第二章 关系运算模型和关系运算理论/","content":"## 2.1 关系模型的基本概念\n\n概念\n\n- 用二维表格表示实体集，用关键码进行数据导航\n\n- 属性、属性值、关系模式、元组、关系、行、列\n\n- 关系元数、基数\n\n  ![image-20210309183459413](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210309183459.png)\n\n- 关键码\n  - 超键\n  - 候选键\n  - 主键\n  - 外键\n\n\n\n关系：属性数目和类型相同的元组的集合\n\n性质\n\n- 每个属性值都不可分解\n- 不允许出现重复元组（重复元组关系码会相同）\n- 不考虑顺序（即行序）\n- 属性理论上也无序，但使用时按习惯排列\n\n\n\n完整性规则\n\n1. 实体完整性规则：主键不能是空值\n2. 参照完整性规则：“不允许引用不存在的实体”\n3. 用户定义的完整性规则：针对具体的数据进行的约束\n\n\n\nER模型向关系模型的转换规则\n\n1. 每个实体类型转换成一个关系模式\n2. 二元联系类型的转换\n   - 1 对 1\n   - 1 对 N\n   - N 对 N\n\n\n\n三级模式\n\n- 关系模式\n- 子模式/外模式：给特定用户使用\n- 存储模式：文件内部的存储方式\n\n\n\n关系模型的形式定义：\n\n1. 数据结构：全部数据和相互联系\n\n2. 数据操纵：一组完备的高级关系运算，关系代数、关系演算、关系逻辑\n\n3. 数据完整性规则\n\n\n\n## 2.2 关系代数\n\nSQL -> 查询优化 ->关系代数表达式 \n\n五个基本操作：并、差、笛卡尔积、投影（选择特定的列/属性）、选择（选择特定的行/元组）\n\n\n\n四个组合操作\n\n- 交\n- 连接 join\n  - θ连接\n  - F连接\n- 自然连接：公共属性上值相等的进行连接\n- 除法\n\n\n\n关系代数的七个扩充操作\n\n- 改名\n- 广义投影\n- 赋值\n- **外连接**\n- **外部并**\n- **半连接**\n- 聚焦操作\n\n\n\n## 2.3 关系演算\n\n元组关系演算\n\n域关系演算\n\n\n\n## 2.4 关系代数表达式的优化\n\n等价变换规则\n\n优化算法","categories":["数据库"]},{"title":"数据库引论 第一章 数据库概论","url":"/2021/03/15/数据库引论 第一章 数据库概念/","content":"## 1.1 数据库的由来和发展\n\n文件系统->数据库->数据仓库\n\n数据库系统：\n\n- 层次数据库：IMS\n- 网状数据库：IDS\n- 关系数据库：Oracle、DB2 ...\n- 新一代数据库产品：MySQL、MongoDB、Redis、Neoj4、Kafka、Elastic Search ...\n\n大数据时代：大数据思维 -- 关联\n\n## 1.2 数据描述\n\n现实世界（概念设计）->数据库管理系统（逻辑设计）->数据库（物理设计）\n\n数据模型：概念数据模型和逻辑数据模型（包括数据结构、数据操作和数据完整性约束）\n\n### 概念设计的数据描述\n\n实体关系模型：实体、属性、联系。\n\n数据联系的描述：\n\n- 二元联系：一对一、一对多、多对多\n- 三元联系：乘客、飞机、航班\n- 一元联系：零件和组成\n\n实体联系图（ER图）\n\n### 逻辑设计的数据描述\n\n主要的数据模型：\n\n- 层次模型：树形\n- 网状模型：有向图（和ER模型直接的映射）\n- 关系模型：二维表格\n- 对象模型：实体的模型化（类），对关系模型的补充（对象关系模型）\n\n数据描述：\n\n- 字段 field\n- 记录 record\n- 文件 file\n- 关键码 key\n\n### 物理设计的数据描述\n\nbit、byte、word、block（内存和外存交换信息的最小单位）、bucket、volume\n\n## 1.3 数据库体系结构\n\n三个层次：外部级（用户视图）、概念级（全局视图）、内部级（存储视图）\n\n## 1.4 数据库管理系统（DBMS）\n\n### 工作模式\n\n在应用程序和DB之间发挥作用\n\n### 主要功能\n\n1. 数据库定义\n2. 数据库操纵\n3. 数据库保护\n4. 数据库维护\n5. 数据字典\n\n### 模块组成\n\n- 数据库用户\n\n- 查询处理器\n- 存储管理器\n- 磁盘存储器\n\n## 1.5 数据库系统 （DBS）\n\n","categories":["数据库"]},{"title":"Redis","url":"/2021/03/14/Redis/","content":"Redis 是速度非常快的非关系型（NoSQL）内存键值数据库，可以存储键和五种不同类型的值之间的映射。\n\n\n\n数据类型\n\n- STRING：字符串、整数或者浮点数\n- LIST：列表\n- SET：无序集合\n- HASH：包含键值对的无序散列表\n- ZEST：有序集合\n\n\n\n\n\n","categories":["数据库"]},{"title":"MySQL","url":"/2021/03/14/MySQL/","content":"## 索引\n\nB Tree 平衡树：一颗查找树，且所有叶子节点位于同一层\n\nB+ Tree：基于B Tree和叶子节点顺序访问指针实现，一个节点中的 key 从左到右非递减排列\n\n\n\nMySQL索引\n\n- B+Tree索引\n- 哈希索引\n- 全文索引\n- 空间数据索引\n\n\n\n索引对中到大型的表十分有效，非常小的表适合直接全表扫描，特大型的表需要使用别的技术，比如分区技术。\n\n\n\n## 查询性能优化\n\n- 优化数据访问\n  - 减少请求的数据量\n  - 减少服务器扫描的次数\n\n- 重构查询方式\n  - 切分大查询\n  - 分解大连接查询\n\n\n\n## 存储引擎\n\n- InnoDB：MySQL默认的事务存储引擎\n\n- MyISAM\n\n\n\n## 数据类型\n\n- 整型：TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT \n- 浮点数：FLOAT，DOUBLE，DECIMAL\n- 字符串：CHAR，VARCHAR（变长）\n- 时间：DATETIME 和 TIMESTAMP\n\n\n\n## 切分\n\n- 水平切分：将同一个表中的记录拆分到多个结构相同的表中。\n- 垂直切分：将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分。\n\n\n\n## 复制\n\n- 主从复制\n\n  ![image-20210314170503058](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210314170503.png)\n\n- 读写分离：主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作\n\n\n\n","categories":["数据库"]},{"title":"SQL语法","url":"/2021/03/14/SQL语法/","content":"```sql\n## 注释\nSELECT *\nFROM mytable; -- 注释\n/* 注释1\n   注释2 */\n   \n## 创建\nCREATE DATABASE test;\nUSE test;\n\nCREATE TABLE mytable (\n\t...\n\t);\n\n## 修改表\nALTER TABLE mytable\nADD col CHAR(20);\n\nALTER TABLE mytable\nDROP COLUMN col;\n\nDROP TABLE mytable;\n\n## 插入数据\nINSERT INTO mytable(col1, col2)\nVALUES(val1, val2);\n\nINSERT INTO mytable1(col1, col2)\nSELECT col1, col2\nFROM mytable2;\n\nCREATE TABLE newtable AS\nSELECT * FROM mytable;\n\n## 更新\nUPDATE mytable\nSET col = val\nWHERE id = 1;\n\n## 删除\nDELETE FROM mytable\nWHERE id = 1;\n\n## 查询语法\nSELECT DISTINCT col1, col2\nFROM mytable;\n\nSELECT *\nFROM mytable\nLIMIT 2, 3;\n\n## 排序\nSELECT *\nFROM mytable\nORDER BY col1 DESC, col2 ASC;\n\n## 过滤\nSELECT *\nFROM mytable\nWHERE col IS NULL;\n\n## 通配符\nSELECT *\nFROM mytable\nWHERE col LIKE '[^AB]%'; \n\n## 计算\nSELECT col1 * col2 AS alias\nFROM mytable;\n\n## 函数\nSELECT AVG(DISTINCT col1) AS avg_col\nFROM mytable;\n\nSELECT *\nFROM mytable\nWHERE SOUNDEX(col1) = SOUNDEX('apple')\n\n## 分组\nSELECT col, COUNT(*) AS num\nFROM mytable\nGROUP BY col;\n\n## 子查询\nSELECT *\nFROM mytable1\nWHERE col1 IN (SELECT col2\n               FROM mytable2);\n               \n## 连接\nSELECT A.value, B.value\nFROM tablea AS A INNER JOIN tableb AS B\nON A.key = B.key;--内连接\n\nSELECT e1.name\nFROM employee AS e1 INNER JOIN employee AS e2\nON e1.department = e2.department\n      AND e2.name = \"Jim\";--自连接\n      \nSELECT A.value, B.value\nFROM tablea AS A NATURAL JOIN tableb AS B;--自然连接\n\nSELECT Customers.cust_id, Customer.cust_name, Orders.order_id\nFROM Customers LEFT OUTER JOIN Orders\nON Customers.cust_id = Orders.cust_id;--外连接\n\n## 组合查询\nSELECT col\nFROM mytable\nWHERE col = 1\nUNION\nSELECT col\nFROM mytable\nWHERE col =2;\n\n## 视图\nCREATE VIEW myview AS\nSELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col\nFROM mytable\nWHERE col5 = val;\n```\n\n其他语法：\n\n- 存储\n- 游标\n- 触发器\n- 事务管理\n- 字符集\n- 权限管理\n- ...","categories":["数据库"]},{"title":"数据库系统原理","url":"/2021/03/14/数据库系统原理/","content":"## 事务\n\n概念：满足ACID特性的一组操作，Commit提交，Rollback回滚\n\nACID：\n\n1. 原子性\n\n2. 一致性\n\n3. 隔离性\n\n4. 持久性\n\n   ![image-20210311221928533](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210311221928.png)\n\nMySQL默认采用自动提交模式，每个查询操作都会被当做一个事务并自动提交\n\n\n\n## 并发一致性问题\n\n产生原因：并发环境下，事务的隔离性很难保证\n\n- 丢失修改\n- 读脏数据\n- 不可重复读\n- 幻影读\n\n\n\n## 封锁\n\n锁开销和并发程度的平衡\n\n行级锁和表级锁\n\n类型\n\n1. 读写锁：互斥锁（X）/共享锁（S） （行级锁）\n2. 意向锁：增加IX/IS（表级锁）\n\n封锁协议\n\n1. 三级封锁协议\n2. 两段锁协议\n\n\n\n## 隔离级别\n\n- 未提交读\n- 提交读\n- 可重复读\n- 可串行化\n\n隔离级别能解决的并发一致性问题\n\n|          | 脏读 | 不可重复读 | 幻影读 |\n| -------- | ---- | ---------- | ------ |\n| 未提交读 | ×    | ×          | ×      |\n| 提交读   | √    | ×          | ×      |\n| 可重复读 | √    | √          | ×      |\n| 可串行化 | √    | √          | √      |\n\n\n\n## 多版本并发控制\n\nMySQL的InnoDB存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。\n\n\n\n## Next-Key Locks\n\nMySQL的InnoDB存储引擎的一种锁实现。\n\n- Record Locks\n- Gap Locks\n- Next-Key Locks\n\n\n\n## 关系数据库设计理论\n\n- 函数依赖：B函数依赖于A A->B\n- 异常\n  - 冗余数据\n  - 修改异常\n  - 删除异常\n  - 插入异常\n- 范式：用于解决异常\n  - 第一范式：属性不可分\n  - 第二范式：每个非主属性完全依赖与键码\n  - 第三范式：非主属性不传递函数依赖于键码\n\n\n\n## ER图\n\nEntity-Relationship\n\n实体、属性、联系\n\n实体联系\n\n- 一对一\n\n- 一对多\n\n- 多对多\n\n  ![image-20210314160714021](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210314160721.png)\n\n多次出现的关系\n\n![image-20210314160757908](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210314160757.png)\n\n多向的联系\n\n![image-20210314160905040](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210314160905.png)\n\n子类\n\n![image-20210314160840089](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210314160840.png)\n\n","categories":["数据库"]},{"title":"第1章 量化设计与分析基础","url":"/2021/03/14/第1章 量化设计与分析基础/","content":"## 定义\n\n体系结构：涵盖了计算机设计的所有三个方面：指令集体系结构、组成、硬件\n\n## 可信任度\n\n- 模块可靠性：从一个参考初始时刻开始持续提供服务的度量。\n\n- 模块可用性：系统正常工作的时间在连续两次正常服务间隔时间中所占的比率 \n  $$\n  可用性=\\frac{MTTF}{MTTF+MTTR}\n  $$\n  \n\n## 性能的测量、报告和汇总\n\n计算机用户关心缩短响应时间（执行时间），数据处理中心的操作人员关心吞吐量\n\nX比Y快：X的执行时间比Y少\n\n响应时间和CPU时间\n\n\n\n基准测试程序：对使用同一种语言编写的程序采用同一种编译器和相同的一组编译标志\n\n基准测试程序套件：由各种不同的真实应用程序构成，SPEC系列\n\nSPECRatio：将基准计算机上的执行时间除以待评价计算机上的执行时间，得到一个与性能成正比的比值。用几何平均来计算均值。\n$$\n几何平均=\\sqrt[n]{\\prod_{i=1}^{n}{样本_i}}\n$$\n\n## 计算机设计的量化原理\n\n充分利用并行性、程序局部性原理（时间和空间）、重点关注经常性事件\n\nAmdahl定律：加快某部件执行速度所能获得的系统性能加速比，受限于该部件的执行时间占系统中总执行时间的百分比。\n$$\n加速比=\\frac{1}{(1-可改进比例)+\\frac{可改进比例}{部件加速比}}\n$$\n如果只针对整个任务的一部分进行改进和优化，那么所获得的加速比不超过**1/（1-可改进比例）**\n\n\n\n处理器性能公式：\n$$\nCPU时钟周期数=\\sum_{n=1}^{n}{(CPI_i*IC_i)}\n$$\n\n$$\n总CPI=\\frac{时钟周期数}{IC}=\\sum_{n=1}^{n}{(CPI_i*\\frac{IC_i}{IC})}\n$$\n\n其中$\\frac{IC_i}{IC}$表示第i种指令在程序中所占比例\n\n","categories":["计算机体系结构"]},{"title":"Home Page","url":"/2021/03/13/this-is-home-page/","content":"\nWelcome to my Blog !"},{"title":"第二章 算法基础","url":"/2021/03/13/第二章 算法基础/","content":"## 2.1 插入排序\n\n```Java\nfor j <- 2 to length[A]\n\tdo key <- A[j]\n    //将A[j]插入A[1...j-1]\n    i = j - 1\n    while i > 0 and A[i] > key\n         A[i + 1] <- A[i]\n         i <- i - 1\n    A[i + 1] <- key\n```\n\n正确性证明：循环不变式A[1...j-1]\n\n1. 初始化：循环第一次迭代前为真\n2. 保持：若循环的某次迭代前为真，那么下次迭代前它仍然为真\n3. 终止：在循环终止时，不变式提供一个性质，该性质有助于证明算法正确性\n\n\n\n## 2.2 分析算法\n\n- 描述算法所用资源及其代价的模型：随机访问机RAM模型\n\n- 最坏情况与平均情况分析：往往考虑最坏情况（例如输入数组是反向排好序的）\n\n- 增长量级：只考虑运行时间公式中最重要的项，如Θ(n^2)\n\n\n\n## 2.3 算法设计\n\n- 分治法（Divide Conquer Combine）\n\n  归并排序\n\n  ![image-20210308152734063](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210308152734.png)\n\n- 归并排序的分析：递归树\n\n  ![image-20210308153637122](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210308153637.png)\n\n","categories":["算法导论"]},{"title":"第三章 函数的增长","url":"/2021/03/13/第三章 函数的增长/","content":"## 渐进记号\n\n- Θ记号：等于（即f(n) = Θ(g(n))，f(n) = g(n)，下同）\n- O记号：小于等于、最坏情况，时间复杂度上界\n- Ω记号：大于等于\n- o记号：小于\n- ω记号：大于\n\n\n\n## 常用函数\n\n- 多项式\n- 指数\n- 对数\n- 阶乘\n- 多重函数（多重对数函数lg*n）\n- 斐波那契数","categories":["算法导论"]},{"title":"计算机网络 知识点整理","url":"/2021/03/13/计算机网络 知识点整理/","content":"## 概述\n- ISP：互联网服务提供商，多层次结构\n\n- 通信方式：客户-服务器（C/S），对等（P2P）\n\n- 电路交换和分组交换（时延=排队时延+处理时延+传输时延+传播时延）\n\n- OSI（七层协议）、五层协议、TCP/IP（四层）\n\n## 物理层\n- 单工通信、半双工通信和全双工通信\n\n- 带通调制：数字信号（离散）-> 模拟信号（连续）\n\n## 链路层\n### 基本概念\n- 封装成帧：给网络层的分组（IP数据报）添加首部和尾部\n- 透明传输：给数据中和首部尾部相同的内容加转义字符（透明）\n- 差错检测：主要使用循环冗余码CRC\n\n### 信道\n- 分类：广播信道（用信道复用技术和CSMA/CD协议控制）和点对点信道（用PPP协议控制）\n- 信道复用技术：频分复用、时分复用、统计时分复用、波分复用、码分复用（码片正交）\n- CSMA/CD协议：每个主机都不停监听信道，如果在发送过程中其他主机正在发送，说明发生了碰撞（因为有传播时延），等待一段时间在发送（用截断二进制指数退避法确定时间）\n- 争用期：传播时延的两倍\n- PPP协议：用户计算机和ISP之间的链路层协议\n\n### 其他概念\n- MAC地址：6字节，用于唯一标识网络适配器（网卡）\n- 局域网：一种典型的广播信道，主要以太网（星型）等\n- 交换机：存储MAC地址到接口的映射\n- 虚拟局域网：用于建立和物理位置无关的逻辑组\n\n## 网络层\n### IP\n- 数据报格式\n\n  ![IP former](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210307211309.jpg)\n\n- 编址方式：网络号+子网号+主机号、CIDR记法（无分类，网络前缀号+主机号）\n\n### 协议\n- 地址解析协议ARP：\n实现由IP地址得到MAC地址，每个主机上有一个ARP高速缓存，保存本地局域网上的各主机和路由器的IP地址到MAC地址到映射表。若没有映射会发送广播请求。\n- 网际控制报文协议ICMP\n更有效地转发IP数据报和提高交付成功的机会。\nPing：用来测试两台主机之间的联通性。\nTraceroute：用来跟踪一个分组从源点到终点的路径。\n\n### 路由\n- 路由器\n功能：路由转发和分组转发\n组成：交换结构、一组输入端口和一组输出端口\n- 分组转发流程\n- 路由选择协议\n\t1. 内部网关协议RIP\n\t2. 内部网关协议OSPF\n\t3. 外部网关协议BGP\n\n### 其他\n- 虚拟专用网VPN（机构内使用仅在本机有效的专用地址块，有三个）\n- 网络地址转换NAT：将专用网内部的主机使用的本地IP转换成全球IP\n\n## 传输层\n### TCP\n- 格式\n\n  ![image-20210307213853892](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210307213854.png)\n\n- 三次握手\n\n- 四次挥手\n\n- 可靠传输：采用超时重传机制\n\n- 滑动窗口和流量控制\n\n- 拥塞控制\n\n  1. 慢开始和拥塞避免\n  2. 快重传与快恢复\n\n### UDP\n\n格式\n\n<img src=\"https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210307214238.png\" alt=\"image-20210307214238091\" style=\"zoom:50%;\" />\n\n## 应用层\n### DNS\n\n提供主机名和IP地址之间的相互转换\n\n### Web页面请求过程\n\n1. DHCP配置主机信息\n2. ARP解析MAC地址\n3. DNS解析域名\n4. HTTP请求页面\n5. 浏览器渲染\n\n### HTTP\n\n- 方法、状态码、首部字段\n- HTTPS、HTTP1.1特性\n\n### 其他协议\n\n- FTP文件传输协议\n- DHCP动态主机配置协议\n- TELNET远程登录协议\n- 电子邮件协议SMTP和POP3/IMAP","categories":["网络"]},{"title":"操作系统 知识点总结","url":"/2021/03/13/操作系统 知识点总结/","content":"## 进程管理\n### 进程和线程\n- 进程是资源分配的单位。\n- 线程是独立调度的基本单位，是进程内部的一个执行序列。是进程划分的更小的运行单位。\n- 线程共享进程的堆和方法区（元空间），每个线程有自己的程序计数器、虚拟机栈和本地方法栈。\n\n### 进程状态\n5种状态：new, ready, running, waiting, terminated.\n\n### 进程间通信\n7种常见方式：管道/匿名管道（父子进程或兄弟进程间）、有名管道（实现本机任意两个进程通信）、信号、消息队列（消息的列表，存放在内核，克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺陷）、信号量、共享内存、套接字（客户端和服务器之间）。\n\n### 进程调度算法\n- 先到先服务\n- 短作业优先\n- 时间片轮转\n- 多级反馈队列调度\n- 优先级调度\n\n### 进程同步\n- 概念：临界区、同步与互斥\n- 信号量解决同步问题\n- 管程：把同步互斥问题的代码独立出来\n- 经典问题：哲学家进餐、读者写者\n\n### 其他\n1. 孤儿进程（父进程退出，子进程还在，没有危害），僵尸进程（子进程退出，父进程没有释放子进程信息，可能因为没有可用进程号导致不能产生新进程）\n2. 线程同步：互斥量、信号量、事件\n3. 实时系统（硬实时和软实时）\n\n### 死锁\n- 必要条件：互斥、占有等待、不可抢占、环路等待\n\n- 处理方法\n1. 鸵鸟策略：Unix,Linux,Windows都采用\n2. 死锁检测和恢复\n3. 死多预防（破坏必要条件）\n4. 死锁避免：安全状态、银行家算法\n\n## 内存管理\n内存管理主要负责内存的分配和回收以及地址转换。\n\n### 内存管理机制\n- 虚拟内存：让物理内存扩充成更大的逻辑内存，MMU管理地址空间和物理内存的转换\n\n- 连续：块式\n\n- 非连续\n1. 页式：页表（页和页框段映射表），页面号+偏移量。\n2. 段式：一个段构成一个独立地址空间，共享和保护。\n3. 段页式：先分成若干段，每段再分成若干页。\n\n- 快表TLB（加速虚拟地址到物理地址的转换）和多级页表（避免把全部页表一直放在内存中占用过多空间）。\n\n- 分页大小固定，分段大小不固定，段是逻辑信息的基本单位。分页是一维的，分段是二维的。\n\n- 内部碎片和外部碎片\n\n- 局部性原理：时间局部性和空间局部性\n\n- 页面置换算法\n1. OPT最佳\n2. FIFO先进先出\n3. LRU最近最久未使用\n4. LFU最少使用\n5. NRU最近未使用\n6. 第二次机会算法\n7. 时钟算法\n\n## 存储管理\n- 磁盘结构：盘面、磁道、扇区、磁头、制动手臂、主轴。\n\n- 磁盘调度算法：\n1. 先来先服务\n2. 最短寻道时间优先（可能饥饿）\n3. 电梯算法\n\n","categories":["OS"]},{"title":"操作系统 概论","url":"/2021/03/13/操作系统 概论/","content":"## OS:\n1. 管理计算机硬件和软件资源的程序\n2. 屏蔽了硬件层的复杂性\n3. 操作系统内核是核心，负责内存、硬件、文件系统和应用程序的管理。\n4.  操作系统的位数：根据CPU位数设计的\n5. 特征\n- 并发：宏观\n\n- 共享：互斥和同时\n\n- 虚拟：时分复用/空分复用\n\n- 异步\n\n## 系统调用：\n1. 用户态和系统态\n2. 程序需要使用系统级的功能 -> 系统调用\n- 设备管理\n\n- 文件管理\n\n- 进程控制\n\n- 进程通信\n\n- 内存管理\n\n## 其他\n1. 宏内核（一个紧密结合整体）和微内核（只有微内核模块运行在内核态，其他在用户态）\n2. 中断分类\n- 外中断：CPU执行以外的事件（I/O中断等）\n\n- 异常：CPU执行的内部事件（地址溢出等）\n\n- 陷入：系统调用","categories":["OS"]},{"title":"JVM","url":"/2021/03/13/JVM/","content":"## 运行时数据区域\n\n![image-20210310190455920](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210310190456.png)\n\n- 程序计数器：记录正在执行的虚拟机字节码指令的地址\n- Java虚拟机栈：局部变量表、操作数栈、常量池引用\n- 本地方法栈：为本地方法服务\n\n\n\n- 堆：对象分配的内存\n- 方法区：用于存放已被加载的类信息、常量、静态变量、即使编译器编译后的代码\n- 运行常量池：方法区的一部分\n- 直接内存\n\n\n\n## 垃圾回收机制\n\n- 判断一个对象是否可回收\n\n  1. 引用计数法\n  2. 可达性分析法\n  3. 方法区的回收\n  4. finalize()\n\n- 引用类型\n\n  1. 强引用：不会被回收\n  2. 软引用：内存不够会回收\n  3. 弱引用：一定会回收\n  4. 虚引用：唯一目的是能在这个对象被回收时收到一个系统通知\n\n- 垃圾收集算法\n\n  1. 标记-清除\n\n     ![image-20210311201234494](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210311201234.png)\n\n  2. 标记-整理\n\n     ![image-20210311201254800](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210311201254.png)\n\n  3. 复制\n\n     ![image-20210311201310907](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210311201310.png)\n\n  4. 分代收集：将堆分为新生代和老年代，新生代用复制算法，老年代用标记-清除/标记-整理算法\n\n- 垃圾收集器\n\n  ![image-20210311201436702](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210311201436.png)\n  \n  1. Serial收集器\n  2. ParNew收集器\n  3. Parallel Scavenge收集器\n4. Serial Old收集器\n  5. Parallel Old收集器\n  \n  6. CMS收集器\n  7. G1收集器\n\n\n\n## 内存分配和回收策略\n\nMinor GC：回收新生代，执行频繁，速度快\n\nFull GC：回收老年代和新生代，很少执行，速度慢\n\n- 内存分配策略\n\n  1. 对象优先在Eden分配\n\n  2. 大对象直接进入老年代\n\n  3. 长期存活的对象进入老年代\n\n  4. 动态对象年龄判定\n  5. 空间分配担保\n\n- Full GC的触发条件\n\n  1. 调用System.gc()\n  2. 老年代空间不足\n  3. 空间分配担保失败\n  4. JDK1.7及以前的永久代空间不足\n  5. Concurrent Mode Failure\n\n  \n\n## 类加载机制\n\n- 类的生命周期\n\n![image-20210310192647844](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210310192647.png)\n\n\n\n- 类加载过程\n  1. 加载：\n     - 通过类的完全限定名称获取定义该类的二进制字节流。\n     - 将该字节流表示的静态存储结构转换为方法区的运行时存储结构。\n     - 在内存中生成一个代表该类的 Class 对象，作为方法区中该类各种数据的访问入口。\n  2. 验证：确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身安全\n  3. 准备：为类变量分配内存并设置初始值，使用的是方法区的内存\n  4. 解析：将常量池的符号引用替换为直接引用的过程\n  5. 初始化：真正执行类中定义的Java程序的代码\n- 类初始化时机\n  1. 主动引用：五个场景，必须对类初始化\n     1. 遇到new、getstatic、putstatic、invokestatic\n     2. 使用java.lang.reflect进行反射调用\n     3. 要初始化类，但父类还没初始化\n     4. 执行主类（包含main()）\n     5. 当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果为 REF_getStatic, REF_putStatic, REF_invokeStatic 的方法句柄\n  2. 被动引用：不会触发初始化的引用\n\n\n\n类和类加载器\n\n- 分类：启动类加载器/其他类加载器\n- 双亲委派模型\n- 自定义类加载器实现\n\n\n\n\n\n\n\n\n\n","categories":["Java"]},{"title":"Java容器","url":"/2021/03/13/Java容器/","content":"## 概览\nCollection\n1. Set：TreeSet HashSet LinkedHashSet\n2. List：ArrayList Vector(线程安全) LinkedList\n3. Queue：LinkedList PriorityQueue(基于堆结构实现，可以实现优先级队列，构造大顶堆/小顶堆)\n\nMap：TreeMap HashMap HashTable(线程安全，但应该使用ConcurrentHashMap，其引入了分段锁，效率更高) LinkedHashMap\n\n## 分析\nArrayList\n- 支持快速随机访问、默认大小为10\n- 基于动态数组实现，具有动态扩容性\n\nVector\n- 和ArrayList类似，但用了synchronized进行同步，是线程安全的\n- 可以用Collections.synchronizedList()得到线程安全的ArrayList代替\n\nCopyOnWriteArrayList\n- 读写分离，适用读多写少的情况\n\nLinkedList\n- 基于双向链表实现\n- 不支持随机访问但插入删除效率高\n\n- HashSet基于HashMap实现（都是哈希表），LinkedHashSet是HashSet的子类，内部通过LinkedHashMap实现。\n- TreeSet/TreeMap有序且唯一，基于红黑树实现\n\n- Map（需要键值存储时）：需要排序使用TreeMap，不需要排序使用HashMap，需要保证线程安全时用ConcurrentHashMap\n- Collection（只需要存放元素）：需要唯一用Set，否则用List\n\n\n","categories":["Java"]},{"title":"Java基础","url":"/2021/03/13/Java基础/","content":"数据类型：\n- 八大基本数据类型：byte char short int float long double boolean\n- 包装类型：和基本类型对应，自动装箱和自动拆箱\n- 缓存池：valueOf方法，如果数值在缓冲池范围内，直接调用缓冲池的对象\n\nString字符串\n- Java8中内部用char数组存储，Java9之后，改用byte数组，并用coder标识编码方式\n- String内部定义为final，不可变（可用于缓存hash值）\n- StringBuilder（不是线程安全的）和StringBuffer（线程安全）可变\n- String Pool：保存所有字符串的字面量，如果还没有则编译时添加，也可用intern()添加\n\n运算\n- Java参数使用值传递\n- 类型转换：不能隐式向下转型，但++运算符会进行隐式类型转换\n\n关键字\n1. final：声明数据常量、声明不可重写方法、声明不可继承类\n2. static：静态变量、静态方法等\n\nObject类的通用方法：\n- equals()\n- hashcode()\n- toString()\n- clone()：浅拷贝引用同一对象，深拷贝引用不同对象\n- ...\n\n继承\n- 访问权限修饰符：private protected public 不加表示package内可见\n- 抽象类abstract class、接口interface\n- 用super访问父类构造函数和成员\n- 重写Override：重写一个和父类在方法声明上完全一样的方法\n- 重载Overload：同一个类中指定参数不同的方法\n\nI/O\n- 磁盘操作：File\n- 字节操作：InputStream和OutputStream，适用于媒体文件\n- 字符操作：Reader和Writer，涉及到字符的时候使用\n- 对象操作：\nSerializable\n序列化：将一个对象转换成字节序列，方便存储传输\n- 网络操作：Socket\n- NIO\nNIO以块的方式处理数据，I/O用流方式处理\nNIO非阻塞\nBIO同步阻塞式、NIO同步非阻塞、AIO异步非阻塞\n\n\n其他\n- 运行步骤：源代码经过JDK中的Javac编译成字节码，JVM再转换成可执行的二进制机器码\n\n- 面向对象三大特性：封装、继承和多态\n\n- 反射：运行时提供类的信息 java.lang.reflect\n\n- 异常\n\n  ![image-20210309120114463](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210309120121.png)\n\n- 泛型、注解...","categories":["Java"]},{"title":"Java并发","url":"/2021/03/13/Java并发/","content":"## 使用线程\n- 实现Runnable接口\n- 实现Callable接口\n- 继承Thread类\n- 优先使用实现接口的方法，实现接口的方法只是一个可以在线程中运行的任务，任务是通过线程驱动执行的。\n\n## 基础线程机制\n- Executor：用于管理多个异步任务\n  - CachedThreadPool：一个任务创建一个线程\n  - FixedThreadPool：所有任务只能使用固定大小的线程\n  - SingleThreadExecutor：相当于大小为1的FixedThreadPool\n- Daemon：守护线程\n- sleep()：休眠当前正在执行的线程\n- yield()：声明当前线程已经完成主要任务，建议切换\n\n## 中断\n- InterruptedException：中断时如果该线程处于阻塞、限期等待或无限期等待状态会抛出的异常，提前结束线程，但I/O阻塞和synchronized阻塞不能中断\n- Interrupted()\n- Executor的中断操作：shutdown()和shutdownNow()方法\n\n## 互斥同步\n- Synchronized：JVM提供，可以用来同步一个代码块/方法/类/静态方法\n- ReentrantLock：java.util.concurrent包中的锁（JDK实现的）\n- 除非使用后者的高级功能，否则优先使用synchronized，不会产生死锁问题，JVM会确保锁的释放\n\n## 线程之间的协作\n- join()：在一个线程中调用另一个线程的join()方法，会挂起当前线程，直到目标线程结束\n- wait() notify() notifyAll()：调用 wait() 使得线程等待某个条件满足，线程在等待时会被挂起，当其他线程的运行使得这个条件满足时，其它线程会调用 notify() 或者 notifyAll() 来唤醒挂起的线程。（Object中的方法）\n- Await() signal() signalAll()：java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。\n\n## 线程状态\n- new 新建\n- Runnable 可运行\n- Blocked 阻塞（被动）\n- Waiting 无限期等待（主动）\n- Timed_waiting 限期等待（一定时间后被系统自动唤醒）\n- Terminated 死亡\n\n## J.U.C-AQS\n- CountDownLatch：用来控制一个或多个线程等待多个线程\n- CyclicBarrier：用来控制多个线程互相等待，只有多个线程都到达了，线程才会继续执行\n- Semaphore：类似操作系统信号量，控制对互斥资源的访问\n\n## J.U.C-其他组件\n- FutureTask：可以异步获取执行结果或取消执行任务的场景\n- BlockingQueue：提供FIFO和优先级的阻塞队列实现方法，可以用于实现生产者消费者问题\n- ForkJoin：用于并行计算，类似于MapReduce\n\n## Java内存模型\n- 主内存与工作内存\n\n  ![image-20210311194849104](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210311194849.png)\n\n  所有变量都存储在主内存中\n\n- 内存间交互操作：8个操作实现主内存和工作内存的交互\n\n  ![image-20210311194952576](https://gitee.com/freemansonary/markdown-pic-bed/raw/master/Typora/20210311194952.png)\n\n- 内存模型三大特性\n\n  - 原子性：上述8个操作具有原子性\n  - 可见性：一个线程修改共享变量的值，其他线程能够立刻得知修改（实现方式有volatile、synchronized、final）\n  - 有序性：本线程内观察，所有操作都是有序的；在一个线程内观察另一个线程，所有操作都是无序的\n\n- 先行发生原则：让一个操作无需控制就能先于另一个操作完成\n\n  1. 单一线程原则\n  2. 管程锁定原则\n  3. volatile变量规则\n  4. 线程启动规则\n  5. 线程加入规则\n  6. 线程中断规则\n  7. 对象终结规则\n  8. 传递性\n\n## 线程安全\n- 不可变：一定线程安全，有final、String、枚举类型、Number部分子类\n- 互斥同步：sychronized和ReentrantLock（阻塞同步）\n- 非阻塞同步：乐观的并发策略，先执行，有冲突再补偿\n  - CAS乐观锁\n  - AtomicInteger\n  - ABA\n- 无同步方案：当方法不涉及共享数据时，就不用同步措施\n  - 栈封闭\n  - 线程本地存储\n  - 可重入代码\n\n## 锁优化\n\n主要指JVM对synchronized的优化\n\n- 自旋锁：让一个线程在请求一个共享数据的锁时忙循环一段时间，若能获得锁，则可以避免阻塞状态\n- 锁消除：对于检测出不可能存在竞争的共享数据的锁进行消除\n- 锁粗化：若频繁对一个对象加锁解锁，则将加锁范围扩展到整个操作序列的外部\n- 轻量级锁和偏向锁：JDK1.6引入\n\n## 最佳实践\n1. 给线程起有意义的名字\n\n2. 缩小同步范围\n\n3. 多用同步工具少用wait()和notify()\n\n4. 使用BlockingQueue实现生产者消费者问题\n\n5. 多用并发集合少用同步集合\n\n6. 使用本地变量和不可变类来保证安全\n\n7. 使用线程池而不是直接创建线程","categories":["Java"]},{"title":"上车问题","url":"/2021/03/13/上车问题/","content":"问题描述：火车从始发站（第 1站）开出，在始发站上车的人数为 a，然后到达第 2 站，在第 2 站有人上、下车，但上、下车的人数相同，因此在第 2 站开出时车上的人数保持为 a 人。从第 3 站起，上、下车的人数有如下规律：上车的人数都是前两站上车人数之和，而下车人数等于上一站上车人数，一直到终点站的前一站。已知：共有 n 个车站，始发站上车的人数为 a ，终点站全部下车的人数是 m。试问 第x 站开出时车上的人数是多少？程序运行时，先输入四个整数：始发站上车人数 a，车站数 n，终点站下车人数 m 和所求的站点编号 x。要求输出从 x 站开出时车上的人数。\n\n根据题意列出上车下车人数的表格：\n\n| 车站 | 进站前人数 | 上车人数 | 下车人数 | 出站人数 |\n| ---- | ---------- | -------- | -------- | -------- |\n| 1    | 0          | a        | 0        | a        |\n| 2    | a          | b        | b        | a        |\n| 3    | a          | a+b      | b        | 2a       |\n| 4    | 2a         | a+2b     | a+b      | 2a+b     |\n| 5    | 2a+b       | 2a+3b    | a+2b     | 3a+2b    |\n| ...  | ...        | ...      | ...      | ...      |\n| n-1  | ?          | ?        | ?        | m        |\n| n    | m          | 0        | m        | 0        |\n\n根据表格本题的关键在于根据m求出b\n\n*m=f(n-1)a+g(n-1)b*\n\n求出f和g即可\n\n而出站人数=进站人数 + 上车人数 - 下车人数\n\n每站的上车人数和下车人数可以根据题意递推求得\n\n据此可解决问题\n\nC++代码如下：\n\n```C++\n#include <iostream>\n#include <string>\n\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing std::string;\n\n//每一站上了多少a\nint upa(int n){\n    if(n==1){\n        return 1;\n    }else if(n==2){\n        return 0;\n    }else{\n        return upa(n-1) + upa(n-2);\n    }\n}\n\n//每一站上了多少b\nint upb(int n){\n    if(n==1){\n        return 0;\n    }else if(n==2){\n        return 1;\n    }else{\n        return upb(n-1) + upb(n-2);\n    }\n}\n\n//每一站下了多少a\nint downa(int n){\n    if(n==1 || n==2){\n        return 0;\n    }else{\n        return upa(n-1);\n    }\n}\n\n//每一站下了多少b\nint downb(int n){\n    if(n==1){\n        return 0;\n    }else if(n==2){\n        return 1;\n    }else {\n        return upb(n-1);\n    }\n}\n\n//每一站出的时候有多少a\nint f(int n){\n    if(n==1 || n==2){\n        return 1;\n    }else{\n        return (upa(n) - downa(n)) + f(n-1);\n    }\n}\n\n//每一站出的时候有多少b\nint g(int n){\n    if(n==1 || n==2){\n        return 0;\n    }else{\n        return (upb(n) - downb(n)) + g(n-1);\n    }\n} \nint main()\n{\n\tint a, n, m, x;\n    int b; //b表示第二站上车人数\n\tcout << \"输入始发站上车人数，车站数，终点站下车人数和所求的站点编号：\"<<endl;\n\tcin >> a;\n\tcin >> n;\n\tcin >> m;\n\tcin >> x;\n\t\n\tint ans = 0; \n\t\n    //根据定义m=f(n-1)+g(n-1)，据此求出b\n\tb = (m-(f(n-1) * a)) / g(n-1);\n    //计算第x站出站后人数\n\tans = (f(x)*a) + (g(x)*b);\n\t\n\tcout <<\"第\";\n\tcout <<x;\n\tcout <<\"站开出时车上的人数是:\"; \n\tcout <<ans<<endl;\n    \n    return 0;\n}\n\n```\n\n\n\n\n\n","categories":["算法题解"]},{"title":"Hello World","url":"/2021/03/13/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"}]